"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/Clone.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Clone.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clone: () => (/* binding */ Clone)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\");\n\n\n\n\n\nfunction createSpread(child, {\n  keys = ['near', 'far', 'color', 'distance', 'decay', 'penumbra', 'angle', 'intensity', 'skeleton', 'visible', 'castShadow', 'receiveShadow', 'morphTargetDictionary', 'morphTargetInfluences', 'name', 'geometry', 'material', 'position', 'rotation', 'scale', 'up', 'userData', 'bindMode', 'bindMatrix', 'bindMatrixInverse', 'skeleton'],\n  deep,\n  inject,\n  castShadow,\n  receiveShadow\n}) {\n  let spread = {};\n  for (const key of keys) {\n    spread[key] = child[key];\n  }\n  if (deep) {\n    if (spread.geometry && deep !== 'materialsOnly') spread.geometry = spread.geometry.clone();\n    if (spread.material && deep !== 'geometriesOnly') spread.material = spread.material.clone();\n  }\n  if (inject) {\n    if (typeof inject === 'function') spread = {\n      ...spread,\n      children: inject(child)\n    };else if (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(inject)) spread = {\n      ...spread,\n      children: inject\n    };else spread = {\n      ...spread,\n      ...inject\n    };\n  }\n  if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n    if (castShadow) spread.castShadow = true;\n    if (receiveShadow) spread.receiveShadow = true;\n  }\n  return spread;\n}\nconst Clone = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  isChild = false,\n  object,\n  children,\n  deep,\n  castShadow,\n  receiveShadow,\n  inject,\n  keys,\n  ...props\n}, forwardRef) => {\n  const config = {\n    keys,\n    deep,\n    inject,\n    castShadow,\n    receiveShadow\n  };\n  object = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    if (isChild === false && !Array.isArray(object)) {\n      let isSkinned = false;\n      object.traverse(object => {\n        if (object.isSkinnedMesh) isSkinned = true;\n      });\n      if (isSkinned) return three_stdlib__WEBPACK_IMPORTED_MODULE_3__.SkeletonUtils.clone(object);\n    }\n    return object;\n  }, [object, isChild]);\n\n  // Deal with arrayed clones\n  if (Array.isArray(object)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n      ref: forwardRef\n    }), object.map(o => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: o.uuid,\n      object: o\n    }, config))), children);\n  }\n\n  // Singleton clones\n  const {\n    children: injectChildren,\n    ...spread\n  } = createSpread(object, config);\n  const Element = object.type[0].toLowerCase() + object.type.slice(1);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Element, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, spread, props, {\n    ref: forwardRef\n  }), object.children.map(child => {\n    if (child.type === 'Bone') return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config));\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config, {\n      isChild: true\n    }));\n  }), children, injectChildren);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9DbG9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQkFBc0IsaURBQW9CO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEIsdURBQWE7QUFDekM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHdCQUF3QixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQ2hFO0FBQ0EsS0FBSyxnQ0FBZ0MsZ0RBQW1CLFFBQVEsOEVBQVE7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQzlEO0FBQ0EsR0FBRztBQUNILG1EQUFtRCxnREFBbUIsY0FBYyw4RUFBUTtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixnREFBbUIsUUFBUSw4RUFBUTtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVnQiIsInNvdXJjZXMiOlsiQzpcXGpzcHJvalxccmVhY3QtbGFydHpcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxDbG9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTa2VsZXRvblV0aWxzIH0gZnJvbSAndGhyZWUtc3RkbGliJztcblxuZnVuY3Rpb24gY3JlYXRlU3ByZWFkKGNoaWxkLCB7XG4gIGtleXMgPSBbJ25lYXInLCAnZmFyJywgJ2NvbG9yJywgJ2Rpc3RhbmNlJywgJ2RlY2F5JywgJ3BlbnVtYnJhJywgJ2FuZ2xlJywgJ2ludGVuc2l0eScsICdza2VsZXRvbicsICd2aXNpYmxlJywgJ2Nhc3RTaGFkb3cnLCAncmVjZWl2ZVNoYWRvdycsICdtb3JwaFRhcmdldERpY3Rpb25hcnknLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgJ25hbWUnLCAnZ2VvbWV0cnknLCAnbWF0ZXJpYWwnLCAncG9zaXRpb24nLCAncm90YXRpb24nLCAnc2NhbGUnLCAndXAnLCAndXNlckRhdGEnLCAnYmluZE1vZGUnLCAnYmluZE1hdHJpeCcsICdiaW5kTWF0cml4SW52ZXJzZScsICdza2VsZXRvbiddLFxuICBkZWVwLFxuICBpbmplY3QsXG4gIGNhc3RTaGFkb3csXG4gIHJlY2VpdmVTaGFkb3dcbn0pIHtcbiAgbGV0IHNwcmVhZCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3ByZWFkW2tleV0gPSBjaGlsZFtrZXldO1xuICB9XG4gIGlmIChkZWVwKSB7XG4gICAgaWYgKHNwcmVhZC5nZW9tZXRyeSAmJiBkZWVwICE9PSAnbWF0ZXJpYWxzT25seScpIHNwcmVhZC5nZW9tZXRyeSA9IHNwcmVhZC5nZW9tZXRyeS5jbG9uZSgpO1xuICAgIGlmIChzcHJlYWQubWF0ZXJpYWwgJiYgZGVlcCAhPT0gJ2dlb21ldHJpZXNPbmx5Jykgc3ByZWFkLm1hdGVyaWFsID0gc3ByZWFkLm1hdGVyaWFsLmNsb25lKCk7XG4gIH1cbiAgaWYgKGluamVjdCkge1xuICAgIGlmICh0eXBlb2YgaW5qZWN0ID09PSAnZnVuY3Rpb24nKSBzcHJlYWQgPSB7XG4gICAgICAuLi5zcHJlYWQsXG4gICAgICBjaGlsZHJlbjogaW5qZWN0KGNoaWxkKVxuICAgIH07ZWxzZSBpZiAoLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGluamVjdCkpIHNwcmVhZCA9IHtcbiAgICAgIC4uLnNwcmVhZCxcbiAgICAgIGNoaWxkcmVuOiBpbmplY3RcbiAgICB9O2Vsc2Ugc3ByZWFkID0ge1xuICAgICAgLi4uc3ByZWFkLFxuICAgICAgLi4uaW5qZWN0XG4gICAgfTtcbiAgfVxuICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgaWYgKGNhc3RTaGFkb3cpIHNwcmVhZC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICBpZiAocmVjZWl2ZVNoYWRvdykgc3ByZWFkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICB9XG4gIHJldHVybiBzcHJlYWQ7XG59XG5jb25zdCBDbG9uZSA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgaXNDaGlsZCA9IGZhbHNlLFxuICBvYmplY3QsXG4gIGNoaWxkcmVuLFxuICBkZWVwLFxuICBjYXN0U2hhZG93LFxuICByZWNlaXZlU2hhZG93LFxuICBpbmplY3QsXG4gIGtleXMsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkUmVmKSA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBrZXlzLFxuICAgIGRlZXAsXG4gICAgaW5qZWN0LFxuICAgIGNhc3RTaGFkb3csXG4gICAgcmVjZWl2ZVNoYWRvd1xuICB9O1xuICBvYmplY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoaXNDaGlsZCA9PT0gZmFsc2UgJiYgIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgbGV0IGlzU2tpbm5lZCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LnRyYXZlcnNlKG9iamVjdCA9PiB7XG4gICAgICAgIGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCkgaXNTa2lubmVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzU2tpbm5lZCkgcmV0dXJuIFNrZWxldG9uVXRpbHMuY2xvbmUob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSwgW29iamVjdCwgaXNDaGlsZF0pO1xuXG4gIC8vIERlYWwgd2l0aCBhcnJheWVkIGNsb25lc1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByZWY6IGZvcndhcmRSZWZcbiAgICB9KSwgb2JqZWN0Lm1hcChvID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb25lLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IG8udXVpZCxcbiAgICAgIG9iamVjdDogb1xuICAgIH0sIGNvbmZpZykpKSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgLy8gU2luZ2xldG9uIGNsb25lc1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW46IGluamVjdENoaWxkcmVuLFxuICAgIC4uLnNwcmVhZFxuICB9ID0gY3JlYXRlU3ByZWFkKG9iamVjdCwgY29uZmlnKTtcbiAgY29uc3QgRWxlbWVudCA9IG9iamVjdC50eXBlWzBdLnRvTG93ZXJDYXNlKCkgKyBvYmplY3QudHlwZS5zbGljZSgxKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVsZW1lbnQsIF9leHRlbmRzKHt9LCBzcHJlYWQsIHByb3BzLCB7XG4gICAgcmVmOiBmb3J3YXJkUmVmXG4gIH0pLCBvYmplY3QuY2hpbGRyZW4ubWFwKGNoaWxkID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ0JvbmUnKSByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgICAga2V5OiBjaGlsZC51dWlkLFxuICAgICAgb2JqZWN0OiBjaGlsZFxuICAgIH0sIGNvbmZpZykpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9uZSwgX2V4dGVuZHMoe1xuICAgICAga2V5OiBjaGlsZC51dWlkLFxuICAgICAgb2JqZWN0OiBjaGlsZFxuICAgIH0sIGNvbmZpZywge1xuICAgICAgaXNDaGlsZDogdHJ1ZVxuICAgIH0pKTtcbiAgfSksIGNoaWxkcmVuLCBpbmplY3RDaGlsZHJlbik7XG59KTtcblxuZXhwb3J0IHsgQ2xvbmUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Clone.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      texture.dispose();\n    };\n  }, [texture]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 0.1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.gl);\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n  const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      fbo.dispose();\n    };\n  }, [fbo]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (frames === 1) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n    }\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)(() => {\n    if (frames === Infinity || count < frames) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n      count++;\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.o)(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n  const texture = props.map || textureDefault;\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n    GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n  }), []);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      textureDefault.dispose();\n    };\n  }, [textureDefault]);\n  const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n    map: texture\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMyRDtBQUN0QjtBQUNsQjtBQUNHOztBQUVyRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLHFEQUFRO0FBQy9CLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0Isa0VBQWM7QUFDaEMsdUJBQXVCLHFEQUFRO0FBQy9CLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWEscURBQVE7QUFDckIsdUJBQXVCLHFEQUFRO0FBQy9CLGlCQUFpQix5Q0FBWTtBQUM3Qix5QkFBeUIsMkNBQWMsV0FBVyx3Q0FBSztBQUN2RCxjQUFjLDBDQUFhO0FBQzNCLG9CQUFvQix3REFBcUI7QUFDekMsdUJBQXVCLGdEQUFhO0FBQ3BDO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxFQUFFLHFEQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLFFBQVEscURBQVksY0FBYyxnREFBbUIsQ0FBQywyQ0FBYywrQkFBK0IsZ0RBQW1CO0FBQzlLO0FBQ0E7QUFDQSxHQUFHLGtDQUFrQyxnREFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLGdEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFjO0FBQ3ZDO0FBQ0EsRUFBRSwwQ0FBYSxPQUFPLHFEQUFNO0FBQzVCLDRCQUE0Qiw0REFBa0I7QUFDOUMsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsMENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLHFCQUFxQixnREFBbUIsaUJBQWlCLDhFQUFRLEdBQUc7QUFDNUg7QUFDQSxHQUFHLGlCQUFpQixnREFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFDQUFxQyxnREFBbUIsc0RBQXNELGdEQUFtQix3REFBd0QsZ0RBQW1CLDBDQUEwQyxnREFBbUI7QUFDelE7O0FBRTJFIiwic291cmNlcyI6WyJDOlxcanNwcm9qXFxyZWFjdC1sYXJ0elxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGNvcmVcXEVudmlyb25tZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSwgY3JlYXRlUG9ydGFsLCBhcHBseVByb3BzLCBleHRlbmQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgU2NlbmUsIFdlYkdMQ3ViZVJlbmRlclRhcmdldCwgSGFsZkZsb2F0VHlwZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEdyb3VuZFByb2plY3RlZEVudiB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyB1c2VFbnZpcm9ubWVudCB9IGZyb20gJy4vdXNlRW52aXJvbm1lbnQuanMnO1xuXG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmouY3VycmVudCAmJiBvYmouY3VycmVudC5pc1NjZW5lO1xuY29uc3QgcmVzb2x2ZVNjZW5lID0gc2NlbmUgPT4gaXNSZWYoc2NlbmUpID8gc2NlbmUuY3VycmVudCA6IHNjZW5lO1xuZnVuY3Rpb24gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwgc2NlbmVQcm9wcyA9IHt9KSB7XG4gIHZhciBfdGFyZ2V0JGJhY2tncm91bmRSb3QsIF90YXJnZXQkYmFja2dyb3VuZFJvdDIsIF90YXJnZXQkZW52aXJvbm1lbnRSbywgX3RhcmdldCRlbnZpcm9ubWVudFJvMjtcbiAgLy8gZGVmYXVsdHNcbiAgc2NlbmVQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogMCxcbiAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5OiAxLFxuICAgIGJhY2tncm91bmRSb3RhdGlvbjogWzAsIDAsIDBdLFxuICAgIGVudmlyb25tZW50SW50ZW5zaXR5OiAxLFxuICAgIGVudmlyb25tZW50Um90YXRpb246IFswLCAwLCAwXSxcbiAgICAuLi5zY2VuZVByb3BzXG4gIH07XG4gIGNvbnN0IHRhcmdldCA9IHJlc29sdmVTY2VuZShzY2VuZSB8fCBkZWZhdWx0U2NlbmUpO1xuICBjb25zdCBvbGRiZyA9IHRhcmdldC5iYWNrZ3JvdW5kO1xuICBjb25zdCBvbGRlbnYgPSB0YXJnZXQuZW52aXJvbm1lbnQ7XG4gIGNvbnN0IG9sZFNjZW5lUHJvcHMgPSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJhY2tncm91bmRCbHVycmluZXNzOiB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJhY2tncm91bmRJbnRlbnNpdHk6IHRhcmdldC5iYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBiYWNrZ3JvdW5kUm90YXRpb246IChfdGFyZ2V0JGJhY2tncm91bmRSb3QgPSAoX3RhcmdldCRiYWNrZ3JvdW5kUm90MiA9IHRhcmdldC5iYWNrZ3JvdW5kUm90YXRpb24pID09IG51bGwgfHwgX3RhcmdldCRiYWNrZ3JvdW5kUm90Mi5jbG9uZSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldCRiYWNrZ3JvdW5kUm90Mi5jbG9uZSgpKSAhPT0gbnVsbCAmJiBfdGFyZ2V0JGJhY2tncm91bmRSb3QgIT09IHZvaWQgMCA/IF90YXJnZXQkYmFja2dyb3VuZFJvdCA6IFswLCAwLCAwXSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZW52aXJvbm1lbnRJbnRlbnNpdHk6IHRhcmdldC5lbnZpcm9ubWVudEludGVuc2l0eSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZW52aXJvbm1lbnRSb3RhdGlvbjogKF90YXJnZXQkZW52aXJvbm1lbnRSbyA9IChfdGFyZ2V0JGVudmlyb25tZW50Um8yID0gdGFyZ2V0LmVudmlyb25tZW50Um90YXRpb24pID09IG51bGwgfHwgX3RhcmdldCRlbnZpcm9ubWVudFJvMi5jbG9uZSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldCRlbnZpcm9ubWVudFJvMi5jbG9uZSgpKSAhPT0gbnVsbCAmJiBfdGFyZ2V0JGVudmlyb25tZW50Um8gIT09IHZvaWQgMCA/IF90YXJnZXQkZW52aXJvbm1lbnRSbyA6IFswLCAwLCAwXVxuICB9O1xuICBpZiAoYmFja2dyb3VuZCAhPT0gJ29ubHknKSB0YXJnZXQuZW52aXJvbm1lbnQgPSB0ZXh0dXJlO1xuICBpZiAoYmFja2dyb3VuZCkgdGFyZ2V0LmJhY2tncm91bmQgPSB0ZXh0dXJlO1xuICBhcHBseVByb3BzKHRhcmdldCwgc2NlbmVQcm9wcyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gb2xkZW52O1xuICAgIGlmIChiYWNrZ3JvdW5kKSB0YXJnZXQuYmFja2dyb3VuZCA9IG9sZGJnO1xuICAgIGFwcGx5UHJvcHModGFyZ2V0LCBvbGRTY2VuZVByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50TWFwKHtcbiAgc2NlbmUsXG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgbWFwLFxuICAuLi5jb25maWdcbn0pIHtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXApIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBtYXAsIGNvbmZpZyk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50Q3ViZSh7XG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgc2NlbmUsXG4gIGJsdXIsXG4gIGJhY2tncm91bmRCbHVycmluZXNzLFxuICBiYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICBiYWNrZ3JvdW5kUm90YXRpb24sXG4gIGVudmlyb25tZW50SW50ZW5zaXR5LFxuICBlbnZpcm9ubWVudFJvdGF0aW9uLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IHRleHR1cmUgPSB1c2VFbnZpcm9ubWVudChyZXN0KTtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCB0ZXh0dXJlLCB7XG4gICAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogYmx1ciAhPT0gbnVsbCAmJiBibHVyICE9PSB2b2lkIDAgPyBibHVyIDogYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gICAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICAgICAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICAgICAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gICAgICBlbnZpcm9ubWVudFJvdGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICB9O1xuICB9LCBbdGV4dHVyZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50UG9ydGFsKHtcbiAgY2hpbGRyZW4sXG4gIG5lYXIgPSAwLjEsXG4gIGZhciA9IDEwMDAsXG4gIHJlc29sdXRpb24gPSAyNTYsXG4gIGZyYW1lcyA9IDEsXG4gIG1hcCxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBibHVyLFxuICBiYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICBlbnZpcm9ubWVudEludGVuc2l0eSxcbiAgZW52aXJvbm1lbnRSb3RhdGlvbixcbiAgc2NlbmUsXG4gIGZpbGVzLFxuICBwYXRoLFxuICBwcmVzZXQgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0pIHtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgY29uc3QgY2FtZXJhID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbdmlydHVhbFNjZW5lXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBTY2VuZSgpKTtcbiAgY29uc3QgZmJvID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZmJvID0gbmV3IFdlYkdMQ3ViZVJlbmRlclRhcmdldChyZXNvbHV0aW9uKTtcbiAgICBmYm8udGV4dHVyZS50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICByZXR1cm4gZmJvO1xuICB9LCBbcmVzb2x1dGlvbl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmYm8uZGlzcG9zZSgpO1xuICAgIH07XG4gIH0sIFtmYm9dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZnJhbWVzID09PSAxKSB7XG4gICAgICBjb25zdCBhdXRvQ2xlYXIgPSBnbC5hdXRvQ2xlYXI7XG4gICAgICBnbC5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgY2FtZXJhLmN1cnJlbnQudXBkYXRlKGdsLCB2aXJ0dWFsU2NlbmUpO1xuICAgICAgZ2wuYXV0b0NsZWFyID0gYXV0b0NsZWFyO1xuICAgIH1cbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgZmJvLnRleHR1cmUsIHtcbiAgICAgIGJhY2tncm91bmRCbHVycmluZXNzOiBibHVyICE9PSBudWxsICYmIGJsdXIgIT09IHZvaWQgMCA/IGJsdXIgOiBiYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgICAgIGJhY2tncm91bmRJbnRlbnNpdHksXG4gICAgICBiYWNrZ3JvdW5kUm90YXRpb24sXG4gICAgICBlbnZpcm9ubWVudEludGVuc2l0eSxcbiAgICAgIGVudmlyb25tZW50Um90YXRpb25cbiAgICB9KTtcbiAgfSwgW2NoaWxkcmVuLCB2aXJ0dWFsU2NlbmUsIGZiby50ZXh0dXJlLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBiYWNrZ3JvdW5kLCBmcmFtZXMsIGdsXSk7XG4gIGxldCBjb3VudCA9IDE7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBpZiAoZnJhbWVzID09PSBJbmZpbml0eSB8fCBjb3VudCA8IGZyYW1lcykge1xuICAgICAgY29uc3QgYXV0b0NsZWFyID0gZ2wuYXV0b0NsZWFyO1xuICAgICAgZ2wuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICAgIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICAgIGdsLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjcmVhdGVQb3J0YWwoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImN1YmVDYW1lcmFcIiwge1xuICAgIHJlZjogY2FtZXJhLFxuICAgIGFyZ3M6IFtuZWFyLCBmYXIsIGZib11cbiAgfSksIGZpbGVzIHx8IHByZXNldCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50Q3ViZSwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgZmlsZXM6IGZpbGVzLFxuICAgIHByZXNldDogcHJlc2V0LFxuICAgIHBhdGg6IHBhdGgsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCB7XG4gICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICBtYXA6IG1hcCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zXG4gIH0pIDogbnVsbCksIHZpcnR1YWxTY2VuZSkpO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRHcm91bmQocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRncm91bmQsIF9wcm9wcyRncm91bmQyLCBfc2NhbGUsIF9wcm9wcyRncm91bmQzO1xuICBjb25zdCB0ZXh0dXJlRGVmYXVsdCA9IHVzZUVudmlyb25tZW50KHByb3BzKTtcbiAgY29uc3QgdGV4dHVyZSA9IHByb3BzLm1hcCB8fCB0ZXh0dXJlRGVmYXVsdDtcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoe1xuICAgIEdyb3VuZFByb2plY3RlZEVudkltcGw6IEdyb3VuZFByb2plY3RlZEVudlxuICB9KSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0ZXh0dXJlRGVmYXVsdC5kaXNwb3NlKCk7XG4gICAgfTtcbiAgfSwgW3RleHR1cmVEZWZhdWx0XSk7XG4gIGNvbnN0IGFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IFt0ZXh0dXJlXSwgW3RleHR1cmVdKTtcbiAgY29uc3QgaGVpZ2h0ID0gKF9wcm9wcyRncm91bmQgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kLmhlaWdodDtcbiAgY29uc3QgcmFkaXVzID0gKF9wcm9wcyRncm91bmQyID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZDIucmFkaXVzO1xuICBjb25zdCBzY2FsZSA9IChfc2NhbGUgPSAoX3Byb3BzJGdyb3VuZDMgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kMy5zY2FsZSkgIT09IG51bGwgJiYgX3NjYWxlICE9PSB2b2lkIDAgPyBfc2NhbGUgOiAxMDAwO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBtYXA6IHRleHR1cmVcbiAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VuZFByb2plY3RlZEVudkltcGxcIiwge1xuICAgIGFyZ3M6IGFyZ3MsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJhZGl1czogcmFkaXVzXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50KHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5ncm91bmQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEdyb3VuZCwgcHJvcHMpIDogcHJvcHMubWFwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIHByb3BzKSA6IHByb3BzLmNoaWxkcmVuID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRQb3J0YWwsIHByb3BzKSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50Q3ViZSwgcHJvcHMpO1xufVxuXG5leHBvcnQgeyBFbnZpcm9ubWVudCwgRW52aXJvbm1lbnRDdWJlLCBFbnZpcm9ubWVudE1hcCwgRW52aXJvbm1lbnRQb3J0YWwgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Gltf.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Gltf.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gltf: () => (/* binding */ Gltf),\n/* harmony export */   useGLTF: () => (/* binding */ useGLTF)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var _Clone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Clone.js */ \"(ssr)/./node_modules/@react-three/drei/core/Clone.js\");\n\n\n\n\n\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco = true, useMeshopt = true, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_2__.DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder === 'function' ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder);\n    }\n  };\n}\nconst useGLTF = (path, useDraco, useMeshopt, extendLoader) => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G)(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.preload = (path, useDraco, useMeshopt, extendLoader) => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.clear = path => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Clone_js__WEBPACK_IMPORTED_MODULE_6__.Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HbHRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDd0M7QUFDeEI7QUFDWjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQWMsa0JBQWtCLDREQUFjLEtBQUssd0RBQWM7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFEQUFTLENBQUMsb0RBQVU7QUFDbEYsZ0VBQWdFLGlEQUFTLFNBQVMsb0RBQVU7QUFDNUYsd0JBQXdCLGlEQUFTLE9BQU8sb0RBQVU7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qiw2Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixnREFBbUIsQ0FBQyw0Q0FBSyxFQUFFLDhFQUFRO0FBQ3pEO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRXdCIiwic291cmNlcyI6WyJDOlxcanNwcm9qXFxyZWFjdC1sYXJ0elxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGNvcmVcXEdsdGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgR0xURkxvYWRlciwgRFJBQ09Mb2FkZXIsIE1lc2hvcHREZWNvZGVyIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDbG9uZSB9IGZyb20gJy4vQ2xvbmUuanMnO1xuXG5sZXQgZHJhY29Mb2FkZXIgPSBudWxsO1xubGV0IGRlY29kZXJQYXRoID0gJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2RyYWNvL3ZlcnNpb25lZC9kZWNvZGVycy8xLjUuNS8nO1xuZnVuY3Rpb24gZXh0ZW5zaW9ucyh1c2VEcmFjbyA9IHRydWUsIHVzZU1lc2hvcHQgPSB0cnVlLCBleHRlbmRMb2FkZXIpIHtcbiAgcmV0dXJuIGxvYWRlciA9PiB7XG4gICAgaWYgKGV4dGVuZExvYWRlcikge1xuICAgICAgZXh0ZW5kTG9hZGVyKGxvYWRlcik7XG4gICAgfVxuICAgIGlmICh1c2VEcmFjbykge1xuICAgICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgICBkcmFjb0xvYWRlciA9IG5ldyBEUkFDT0xvYWRlcigpO1xuICAgICAgfVxuICAgICAgZHJhY29Mb2FkZXIuc2V0RGVjb2RlclBhdGgodHlwZW9mIHVzZURyYWNvID09PSAnc3RyaW5nJyA/IHVzZURyYWNvIDogZGVjb2RlclBhdGgpO1xuICAgICAgbG9hZGVyLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKHVzZU1lc2hvcHQpIHtcbiAgICAgIGxvYWRlci5zZXRNZXNob3B0RGVjb2Rlcih0eXBlb2YgTWVzaG9wdERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBNZXNob3B0RGVjb2RlcigpIDogTWVzaG9wdERlY29kZXIpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHVzZUdMVEYgPSAocGF0aCwgdXNlRHJhY28sIHVzZU1lc2hvcHQsIGV4dGVuZExvYWRlcikgPT4gdXNlTG9hZGVyKEdMVEZMb2FkZXIsIHBhdGgsIGV4dGVuc2lvbnModXNlRHJhY28sIHVzZU1lc2hvcHQsIGV4dGVuZExvYWRlcikpO1xudXNlR0xURi5wcmVsb2FkID0gKHBhdGgsIHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpID0+IHVzZUxvYWRlci5wcmVsb2FkKEdMVEZMb2FkZXIsIHBhdGgsIGV4dGVuc2lvbnModXNlRHJhY28sIHVzZU1lc2hvcHQsIGV4dGVuZExvYWRlcikpO1xudXNlR0xURi5jbGVhciA9IHBhdGggPT4gdXNlTG9hZGVyLmNsZWFyKEdMVEZMb2FkZXIsIHBhdGgpO1xudXNlR0xURi5zZXREZWNvZGVyUGF0aCA9IHBhdGggPT4ge1xuICBkZWNvZGVyUGF0aCA9IHBhdGg7XG59O1xuXG4vL1xuXG5jb25zdCBHbHRmID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBzcmMsXG4gIHVzZURyYWNvLFxuICB1c2VNZXNoT3B0LFxuICBleHRlbmRMb2FkZXIsXG4gIC4uLnByb3BzXG59LCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIHNjZW5lXG4gIH0gPSB1c2VHTFRGKHNyYywgdXNlRHJhY28sIHVzZU1lc2hPcHQsIGV4dGVuZExvYWRlcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9uZSwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzLCB7XG4gICAgb2JqZWN0OiBzY2VuZVxuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgR2x0ZiwgdXNlR0xURiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Gltf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Lightformer.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Lightformer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lightformer: () => (/* binding */ Lightformer)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n\n\n\nconst Lightformer = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  light,\n  args,\n  map,\n  toneMapped = false,\n  color = 'white',\n  form: Form = 'rect',\n  intensity = 1,\n  scale = 1,\n  target = [0, 0, 0],\n  children,\n  ...props\n}, forwardRef) => {\n  // Apply emissive power\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardRef, () => ref.current, []);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (!children && !props.material) {\n      (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(ref.current.material, {\n        color\n      });\n      ref.current.material.color.multiplyScalar(intensity);\n    }\n  }, [color, intensity, children, props.material]);\n\n  // Target light\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (!props.rotation) ref.current.quaternion.identity();\n    if (target && !props.rotation) {\n      'boolean' === typeof target ? ref.current.lookAt(0, 0, 0) : ref.current.lookAt(Array.isArray(target) ? new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(...target) : target);\n    }\n  }, [target, props.rotation]);\n\n  // Fix 2-dimensional scale\n  scale = Array.isArray(scale) && scale.length === 2 ? [scale[0], scale[1], 1] : scale;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref,\n    scale: scale\n  }, props), Form === 'circle' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"ringGeometry\", {\n    args: args ? args : [0, 0.5, 64]\n  }) : Form === 'ring' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"ringGeometry\", {\n    args: args ? args : [0.25, 0.5, 64]\n  }) : Form === 'rect' || Form === 'plane' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", {\n    args: args ? args : [1, 1]\n  }) : Form === 'box' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"boxGeometry\", {\n    args: args ? args : [1, 1, 1]\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Form, {\n    args: args\n  }), children ? children : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n    toneMapped: toneMapped,\n    map: map,\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide\n  }), light && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"pointLight\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    castShadow: true\n  }, light)));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9MaWdodGZvcm1lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDVjtBQUNqQjtBQUNBOztBQUUvQixtQ0FBbUMsNkNBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLHlDQUFZO0FBQzFCLEVBQUUsc0RBQXlCO0FBQzNCLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0EsTUFBTSxxREFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQSxpSEFBaUgsMENBQWE7QUFDOUg7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CLFNBQVMsOEVBQVE7QUFDMUQ7QUFDQTtBQUNBLEdBQUcsMkNBQTJDLGdEQUFtQjtBQUNqRTtBQUNBLEdBQUcsbUNBQW1DLGdEQUFtQjtBQUN6RDtBQUNBLEdBQUcsdURBQXVELGdEQUFtQjtBQUM3RTtBQUNBLEdBQUcsa0NBQWtDLGdEQUFtQjtBQUN4RDtBQUNBLEdBQUcsaUJBQWlCLGdEQUFtQjtBQUN2QztBQUNBLEdBQUcsc0NBQXNDLGdEQUFtQjtBQUM1RDtBQUNBO0FBQ0EsVUFBVSw2Q0FBZ0I7QUFDMUIsR0FBRyx5QkFBeUIsZ0RBQW1CLGVBQWUsOEVBQVE7QUFDdEU7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFc0IiLCJzb3VyY2VzIjpbIkM6XFxqc3Byb2pcXHJlYWN0LWxhcnR6XFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZHJlaVxcY29yZVxcTGlnaHRmb3JtZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgYXBwbHlQcm9wcyB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IExpZ2h0Zm9ybWVyID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBsaWdodCxcbiAgYXJncyxcbiAgbWFwLFxuICB0b25lTWFwcGVkID0gZmFsc2UsXG4gIGNvbG9yID0gJ3doaXRlJyxcbiAgZm9ybTogRm9ybSA9ICdyZWN0JyxcbiAgaW50ZW5zaXR5ID0gMSxcbiAgc2NhbGUgPSAxLFxuICB0YXJnZXQgPSBbMCwgMCwgMF0sXG4gIGNoaWxkcmVuLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZFJlZikgPT4ge1xuICAvLyBBcHBseSBlbWlzc2l2ZSBwb3dlclxuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZFJlZiwgKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoaWxkcmVuICYmICFwcm9wcy5tYXRlcmlhbCkge1xuICAgICAgYXBwbHlQcm9wcyhyZWYuY3VycmVudC5tYXRlcmlhbCwge1xuICAgICAgICBjb2xvclxuICAgICAgfSk7XG4gICAgICByZWYuY3VycmVudC5tYXRlcmlhbC5jb2xvci5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkpO1xuICAgIH1cbiAgfSwgW2NvbG9yLCBpbnRlbnNpdHksIGNoaWxkcmVuLCBwcm9wcy5tYXRlcmlhbF0pO1xuXG4gIC8vIFRhcmdldCBsaWdodFxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcHJvcHMucm90YXRpb24pIHJlZi5jdXJyZW50LnF1YXRlcm5pb24uaWRlbnRpdHkoKTtcbiAgICBpZiAodGFyZ2V0ICYmICFwcm9wcy5yb3RhdGlvbikge1xuICAgICAgJ2Jvb2xlYW4nID09PSB0eXBlb2YgdGFyZ2V0ID8gcmVmLmN1cnJlbnQubG9va0F0KDAsIDAsIDApIDogcmVmLmN1cnJlbnQubG9va0F0KEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IG5ldyBUSFJFRS5WZWN0b3IzKC4uLnRhcmdldCkgOiB0YXJnZXQpO1xuICAgIH1cbiAgfSwgW3RhcmdldCwgcHJvcHMucm90YXRpb25dKTtcblxuICAvLyBGaXggMi1kaW1lbnNpb25hbCBzY2FsZVxuICBzY2FsZSA9IEFycmF5LmlzQXJyYXkoc2NhbGUpICYmIHNjYWxlLmxlbmd0aCA9PT0gMiA/IFtzY2FsZVswXSwgc2NhbGVbMV0sIDFdIDogc2NhbGU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIHNjYWxlOiBzY2FsZVxuICB9LCBwcm9wcyksIEZvcm0gPT09ICdjaXJjbGUnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyaW5nR2VvbWV0cnlcIiwge1xuICAgIGFyZ3M6IGFyZ3MgPyBhcmdzIDogWzAsIDAuNSwgNjRdXG4gIH0pIDogRm9ybSA9PT0gJ3JpbmcnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyaW5nR2VvbWV0cnlcIiwge1xuICAgIGFyZ3M6IGFyZ3MgPyBhcmdzIDogWzAuMjUsIDAuNSwgNjRdXG4gIH0pIDogRm9ybSA9PT0gJ3JlY3QnIHx8IEZvcm0gPT09ICdwbGFuZScgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIiwge1xuICAgIGFyZ3M6IGFyZ3MgPyBhcmdzIDogWzEsIDFdXG4gIH0pIDogRm9ybSA9PT0gJ2JveCcgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJveEdlb21ldHJ5XCIsIHtcbiAgICBhcmdzOiBhcmdzID8gYXJncyA6IFsxLCAxLCAxXVxuICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm0sIHtcbiAgICBhcmdzOiBhcmdzXG4gIH0pLCBjaGlsZHJlbiA/IGNoaWxkcmVuIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLCB7XG4gICAgdG9uZU1hcHBlZDogdG9uZU1hcHBlZCxcbiAgICBtYXA6IG1hcCxcbiAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gIH0pLCBsaWdodCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBvaW50TGlnaHRcIiwgX2V4dGVuZHMoe1xuICAgIGNhc3RTaGFkb3c6IHRydWVcbiAgfSwgbGlnaHQpKSk7XG59KTtcblxuZXhwb3J0IHsgTGlnaHRmb3JtZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Lightformer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Texture.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Texture.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsObject: () => (/* binding */ IsObject),\n/* harmony export */   Texture: () => (/* binding */ Texture),\n/* harmony export */   useTexture: () => (/* binding */ useTexture)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n\n\n\n\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input, onLoad) {\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.C)(state => state.gl);\n  const textures = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G)(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, IsObject(input) ? Object.values(input) : input);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    onLoad == null || onLoad(textures);\n  }, [onLoad]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if ('initTexture' in gl) {\n      let textureArray = [];\n      if (Array.isArray(textures)) {\n        textureArray = textures;\n      } else if (textures instanceof three__WEBPACK_IMPORTED_MODULE_2__.Texture) {\n        textureArray = [textures];\n      } else if (IsObject(textures)) {\n        textureArray = Object.values(textures);\n      }\n      textureArray.forEach(texture => {\n        if (texture instanceof three__WEBPACK_IMPORTED_MODULE_2__.Texture) {\n          gl.initTexture(texture);\n        }\n      });\n    }\n  }, [gl, textures]);\n  const mappedTextures = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (IsObject(input)) {\n      const keyed = {};\n      let i = 0;\n      for (const key in input) keyed[key] = textures[i++];\n      return keyed;\n    } else {\n      return textures;\n    }\n  }, [input, textures]);\n  return mappedTextures;\n}\nuseTexture.preload = url => _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G.preload(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, url);\nuseTexture.clear = input => _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G.clear(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, input);\n\n//\n\nconst Texture = ({\n  children,\n  input,\n  onLoad\n}) => {\n  const ret = useTexture(input, onLoad);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children == null ? void 0 : children(ret));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9UZXh0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDNkI7QUFDQTtBQUNIOztBQUV6RDtBQUNBO0FBQ0EsYUFBYSxxREFBUTtBQUNyQixtQkFBbUIscURBQVMsQ0FBQyxnREFBYTtBQUMxQyxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZCQUE2QiwwQ0FBUztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQVM7QUFDeEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsOENBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVMsU0FBUyxnREFBYTtBQUMzRCw0QkFBNEIsaURBQVMsT0FBTyxnREFBYTs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsZ0RBQW1CLENBQUMsMkNBQWM7QUFDeEQ7O0FBRXlDIiwic291cmNlcyI6WyJDOlxcanNwcm9qXFxyZWFjdC1sYXJ0elxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGNvcmVcXFRleHR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0dXJlTG9hZGVyLCBUZXh0dXJlIGFzIFRleHR1cmUkMSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG5jb25zdCBJc09iamVjdCA9IHVybCA9PiB1cmwgPT09IE9iamVjdCh1cmwpICYmICFBcnJheS5pc0FycmF5KHVybCkgJiYgdHlwZW9mIHVybCAhPT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIHVzZVRleHR1cmUoaW5wdXQsIG9uTG9hZCkge1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgdGV4dHVyZXMgPSB1c2VMb2FkZXIoVGV4dHVyZUxvYWRlciwgSXNPYmplY3QoaW5wdXQpID8gT2JqZWN0LnZhbHVlcyhpbnB1dCkgOiBpbnB1dCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgb25Mb2FkID09IG51bGwgfHwgb25Mb2FkKHRleHR1cmVzKTtcbiAgfSwgW29uTG9hZF0pO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIyNjk2XG4gIC8vIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVIGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBOT1RFOiBvbmx5IGF2YWlsYWJsZSBmb3IgV2ViR0xSZW5kZXJlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICgnaW5pdFRleHR1cmUnIGluIGdsKSB7XG4gICAgICBsZXQgdGV4dHVyZUFycmF5ID0gW107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0dXJlcykpIHtcbiAgICAgICAgdGV4dHVyZUFycmF5ID0gdGV4dHVyZXM7XG4gICAgICB9IGVsc2UgaWYgKHRleHR1cmVzIGluc3RhbmNlb2YgVGV4dHVyZSQxKSB7XG4gICAgICAgIHRleHR1cmVBcnJheSA9IFt0ZXh0dXJlc107XG4gICAgICB9IGVsc2UgaWYgKElzT2JqZWN0KHRleHR1cmVzKSkge1xuICAgICAgICB0ZXh0dXJlQXJyYXkgPSBPYmplY3QudmFsdWVzKHRleHR1cmVzKTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmVBcnJheS5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICBpZiAodGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUkMSkge1xuICAgICAgICAgIGdsLmluaXRUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtnbCwgdGV4dHVyZXNdKTtcbiAgY29uc3QgbWFwcGVkVGV4dHVyZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoSXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICBjb25zdCBrZXllZCA9IHt9O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIGtleWVkW2tleV0gPSB0ZXh0dXJlc1tpKytdO1xuICAgICAgcmV0dXJuIGtleWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dHVyZXM7XG4gICAgfVxuICB9LCBbaW5wdXQsIHRleHR1cmVzXSk7XG4gIHJldHVybiBtYXBwZWRUZXh0dXJlcztcbn1cbnVzZVRleHR1cmUucHJlbG9hZCA9IHVybCA9PiB1c2VMb2FkZXIucHJlbG9hZChUZXh0dXJlTG9hZGVyLCB1cmwpO1xudXNlVGV4dHVyZS5jbGVhciA9IGlucHV0ID0+IHVzZUxvYWRlci5jbGVhcihUZXh0dXJlTG9hZGVyLCBpbnB1dCk7XG5cbi8vXG5cbmNvbnN0IFRleHR1cmUgPSAoe1xuICBjaGlsZHJlbixcbiAgaW5wdXQsXG4gIG9uTG9hZFxufSkgPT4ge1xuICBjb25zdCByZXQgPSB1c2VUZXh0dXJlKGlucHV0LCBvbkxvYWQpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbihyZXQpKTtcbn07XG5cbmV4cG9ydCB7IElzT2JqZWN0LCBUZXh0dXJlLCB1c2VUZXh0dXJlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Texture.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @monogrid/gainmap-js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nconst defaultFiles = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'];\nfunction useEnvironment({\n  files = defaultFiles,\n  path = '',\n  preset = undefined,\n  colorSpace = undefined,\n  extensions\n} = {}) {\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  // Everything else\n  const multiFile = isArray(files);\n  const {\n    extension,\n    isCubemap\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.gl);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    // Only required for gainmap\n    if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;\n    function clearGainmapTexture() {\n      _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.clear(loader, multiFile ? [files] : files);\n    }\n    gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {\n      once: true\n    });\n  }, [files, gl.domElement]);\n  const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G)(loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      // @ts-expect-error\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? three__WEBPACK_IMPORTED_MODULE_3__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;\n  texture.colorSpace = colorSpace !== null && colorSpace !== void 0 ? colorSpace : isCubemap ? 'srgb' : 'srgb-linear';\n  return texture;\n}\nconst preloadDefaultOptions = {\n  files: defaultFiles,\n  path: '',\n  preset: undefined,\n  extensions: undefined\n};\nuseEnvironment.preload = preloadOptions => {\n  const options = {\n    ...preloadDefaultOptions,\n    ...preloadOptions\n  };\n  let {\n    files,\n    path = ''\n  } = options;\n  const {\n    preset,\n    extensions\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const {\n    extension\n  } = getExtension(files);\n  if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n    throw new Error('useEnvironment: Preloading gainmaps is not supported');\n  }\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.preload(loader, isArray(files) ? [files] : files, loader => {\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n};\nconst clearDefaultOptins = {\n  files: defaultFiles,\n  preset: undefined\n};\nuseEnvironment.clear = clearOptions => {\n  const options = {\n    ...clearDefaultOptins,\n    ...clearOptions\n  };\n  let {\n    files\n  } = options;\n  const {\n    preset\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n  }\n  const {\n    extension\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.clear(loader, isArray(files) ? [files] : files);\n};\nfunction validatePreset(preset) {\n  if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj).join(', '));\n}\nfunction getExtension(files) {\n  var _firstEntry$split$pop;\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  const extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  return {\n    extension,\n    isCubemap,\n    isGainmap\n  };\n}\nfunction getLoader(extension) {\n  const loader = extension === 'cube' ? three__WEBPACK_IMPORTED_MODULE_3__.CubeTextureLoader : extension === 'hdr' ? three_stdlib__WEBPACK_IMPORTED_MODULE_4__.RGBELoader : extension === 'exr' ? three_stdlib__WEBPACK_IMPORTED_MODULE_5__.EXRLoader : extension === 'jpg' || extension === 'jpeg' ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__.HDRJPGLoader : extension === 'webp' ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__.GainMapLoader : null;\n  return loader;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDMEM7QUFDOUM7QUFDYztBQUNMO0FBQ3RCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0EsWUFBWSxzRUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWEscURBQVE7QUFDckIsRUFBRSxzREFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCx1QkFBdUIscURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3REFBcUIsR0FBRyxtRUFBZ0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksc0VBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaURBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksc0VBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFLGlEQUFTO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQixzRUFBVSwyREFBMkQsc0VBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBaUIseUJBQXlCLG9EQUFVLHlCQUF5QixtREFBUyxpREFBaUQsOERBQVksMEJBQTBCLCtEQUFhO0FBQ2xPO0FBQ0E7O0FBRTBCIiwic291cmNlcyI6WyJDOlxcanNwcm9qXFxyZWFjdC1sYXJ0elxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGNvcmVcXHVzZUVudmlyb25tZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVRocmVlLCB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgQ3ViZVRleHR1cmVMb2FkZXIgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBSR0JFTG9hZGVyLCBFWFJMb2FkZXIgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgSERSSlBHTG9hZGVyLCBHYWluTWFwTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnO1xuaW1wb3J0IHsgcHJlc2V0c09iaiB9IGZyb20gJy4uL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQ1VCRU1BUF9ST09UID0gJ2h0dHBzOi8vcmF3LmdpdGhhY2suY29tL3BtbmRycy9kcmVpLWFzc2V0cy80NTYwNjBhMjZiYmViOGZkZjc5MzI2ZjIyNGI2ZDk5YjhiY2NlNzM2L2hkcmkvJztcbmNvbnN0IGlzQXJyYXkgPSBhcnIgPT4gQXJyYXkuaXNBcnJheShhcnIpO1xuY29uc3QgZGVmYXVsdEZpbGVzID0gWycvcHgucG5nJywgJy9ueC5wbmcnLCAnL3B5LnBuZycsICcvbnkucG5nJywgJy9wei5wbmcnLCAnL256LnBuZyddO1xuZnVuY3Rpb24gdXNlRW52aXJvbm1lbnQoe1xuICBmaWxlcyA9IGRlZmF1bHRGaWxlcyxcbiAgcGF0aCA9ICcnLFxuICBwcmVzZXQgPSB1bmRlZmluZWQsXG4gIGNvbG9yU3BhY2UgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0gPSB7fSkge1xuICBpZiAocHJlc2V0KSB7XG4gICAgdmFsaWRhdGVQcmVzZXQocHJlc2V0KTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlXG4gIGNvbnN0IG11bHRpRmlsZSA9IGlzQXJyYXkoZmlsZXMpO1xuICBjb25zdCB7XG4gICAgZXh0ZW5zaW9uLFxuICAgIGlzQ3ViZW1hcFxuICB9ID0gZ2V0RXh0ZW5zaW9uKGZpbGVzKTtcbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKGV4dGVuc2lvbik7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE9ubHkgcmVxdWlyZWQgZm9yIGdhaW5tYXBcbiAgICBpZiAoZXh0ZW5zaW9uICE9PSAnd2VicCcgJiYgZXh0ZW5zaW9uICE9PSAnanBnJyAmJiBleHRlbnNpb24gIT09ICdqcGVnJykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGNsZWFyR2Fpbm1hcFRleHR1cmUoKSB7XG4gICAgICB1c2VMb2FkZXIuY2xlYXIobG9hZGVyLCBtdWx0aUZpbGUgPyBbZmlsZXNdIDogZmlsZXMpO1xuICAgIH1cbiAgICBnbC5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBjbGVhckdhaW5tYXBUZXh0dXJlLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gIH0sIFtmaWxlcywgZ2wuZG9tRWxlbWVudF0pO1xuICBjb25zdCBsb2FkZXJSZXN1bHQgPSB1c2VMb2FkZXIobG9hZGVyLCBtdWx0aUZpbGUgPyBbZmlsZXNdIDogZmlsZXMsIGxvYWRlciA9PiB7XG4gICAgLy8gR2Fpbm1hcCByZXF1aXJlcyBhIHJlbmRlcmVyXG4gICAgaWYgKGV4dGVuc2lvbiA9PT0gJ3dlYnAnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZycgfHwgZXh0ZW5zaW9uID09PSAnanBlZycpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxvYWRlci5zZXRSZW5kZXJlcihnbCk7XG4gICAgfVxuICAgIGxvYWRlci5zZXRQYXRoID09IG51bGwgfHwgbG9hZGVyLnNldFBhdGgocGF0aCk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gIH0pO1xuICBsZXQgdGV4dHVyZSA9IG11bHRpRmlsZSA/XG4gIC8vIEB0cy1pZ25vcmVcbiAgbG9hZGVyUmVzdWx0WzBdIDogbG9hZGVyUmVzdWx0O1xuICBpZiAoZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJyB8fCBleHRlbnNpb24gPT09ICd3ZWJwJykge1xuICAgIHZhciBfcmVuZGVyVGFyZ2V0O1xuICAgIHRleHR1cmUgPSAoX3JlbmRlclRhcmdldCA9IHRleHR1cmUucmVuZGVyVGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3JlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIHRleHR1cmUubWFwcGluZyA9IGlzQ3ViZW1hcCA/IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xuICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlICE9PSBudWxsICYmIGNvbG9yU3BhY2UgIT09IHZvaWQgMCA/IGNvbG9yU3BhY2UgOiBpc0N1YmVtYXAgPyAnc3JnYicgOiAnc3JnYi1saW5lYXInO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cbmNvbnN0IHByZWxvYWREZWZhdWx0T3B0aW9ucyA9IHtcbiAgZmlsZXM6IGRlZmF1bHRGaWxlcyxcbiAgcGF0aDogJycsXG4gIHByZXNldDogdW5kZWZpbmVkLFxuICBleHRlbnNpb25zOiB1bmRlZmluZWRcbn07XG51c2VFbnZpcm9ubWVudC5wcmVsb2FkID0gcHJlbG9hZE9wdGlvbnMgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLnByZWxvYWREZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5wcmVsb2FkT3B0aW9uc1xuICB9O1xuICBsZXQge1xuICAgIGZpbGVzLFxuICAgIHBhdGggPSAnJ1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qge1xuICAgIHByZXNldCxcbiAgICBleHRlbnNpb25zXG4gIH0gPSBvcHRpb25zO1xuICBpZiAocHJlc2V0KSB7XG4gICAgdmFsaWRhdGVQcmVzZXQocHJlc2V0KTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG4gIGNvbnN0IHtcbiAgICBleHRlbnNpb25cbiAgfSA9IGdldEV4dGVuc2lvbihmaWxlcyk7XG4gIGlmIChleHRlbnNpb24gPT09ICd3ZWJwJyB8fCBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogUHJlbG9hZGluZyBnYWlubWFwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKGV4dGVuc2lvbik7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIHVzZUxvYWRlci5wcmVsb2FkKGxvYWRlciwgaXNBcnJheShmaWxlcykgPyBbZmlsZXNdIDogZmlsZXMsIGxvYWRlciA9PiB7XG4gICAgbG9hZGVyLnNldFBhdGggPT0gbnVsbCB8fCBsb2FkZXIuc2V0UGF0aChwYXRoKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgfSk7XG59O1xuY29uc3QgY2xlYXJEZWZhdWx0T3B0aW5zID0ge1xuICBmaWxlczogZGVmYXVsdEZpbGVzLFxuICBwcmVzZXQ6IHVuZGVmaW5lZFxufTtcbnVzZUVudmlyb25tZW50LmNsZWFyID0gY2xlYXJPcHRpb25zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jbGVhckRlZmF1bHRPcHRpbnMsXG4gICAgLi4uY2xlYXJPcHRpb25zXG4gIH07XG4gIGxldCB7XG4gICAgZmlsZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBwcmVzZXRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChwcmVzZXQpIHtcbiAgICB2YWxpZGF0ZVByZXNldChwcmVzZXQpO1xuICAgIGZpbGVzID0gcHJlc2V0c09ialtwcmVzZXRdO1xuICB9XG4gIGNvbnN0IHtcbiAgICBleHRlbnNpb25cbiAgfSA9IGdldEV4dGVuc2lvbihmaWxlcyk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihleHRlbnNpb24pO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICB1c2VMb2FkZXIuY2xlYXIobG9hZGVyLCBpc0FycmF5KGZpbGVzKSA/IFtmaWxlc10gOiBmaWxlcyk7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVQcmVzZXQocHJlc2V0KSB7XG4gIGlmICghKHByZXNldCBpbiBwcmVzZXRzT2JqKSkgdGhyb3cgbmV3IEVycm9yKCdQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhwcmVzZXRzT2JqKS5qb2luKCcsICcpKTtcbn1cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihmaWxlcykge1xuICB2YXIgX2ZpcnN0RW50cnkkc3BsaXQkcG9wO1xuICBjb25zdCBpc0N1YmVtYXAgPSBpc0FycmF5KGZpbGVzKSAmJiBmaWxlcy5sZW5ndGggPT09IDY7XG4gIGNvbnN0IGlzR2Fpbm1hcCA9IGlzQXJyYXkoZmlsZXMpICYmIGZpbGVzLmxlbmd0aCA9PT0gMyAmJiBmaWxlcy5zb21lKGZpbGUgPT4gZmlsZS5lbmRzV2l0aCgnanNvbicpKTtcbiAgY29uc3QgZmlyc3RFbnRyeSA9IGlzQXJyYXkoZmlsZXMpID8gZmlsZXNbMF0gOiBmaWxlcztcblxuICAvLyBFdmVyeXRoaW5nIGVsc2VcbiAgY29uc3QgZXh0ZW5zaW9uID0gaXNDdWJlbWFwID8gJ2N1YmUnIDogaXNHYWlubWFwID8gJ3dlYnAnIDogZmlyc3RFbnRyeS5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2V4cicpID8gJ2V4cicgOiBmaXJzdEVudHJ5LnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vaGRyJykgPyAnaGRyJyA6IGZpcnN0RW50cnkuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS9qcGVnJykgPyAnanBnJyA6IChfZmlyc3RFbnRyeSRzcGxpdCRwb3AgPSBmaXJzdEVudHJ5LnNwbGl0KCcuJykucG9wKCkpID09IG51bGwgfHwgKF9maXJzdEVudHJ5JHNwbGl0JHBvcCA9IF9maXJzdEVudHJ5JHNwbGl0JHBvcC5zcGxpdCgnPycpKSA9PSBudWxsIHx8IChfZmlyc3RFbnRyeSRzcGxpdCRwb3AgPSBfZmlyc3RFbnRyeSRzcGxpdCRwb3Auc2hpZnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9maXJzdEVudHJ5JHNwbGl0JHBvcC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbixcbiAgICBpc0N1YmVtYXAsXG4gICAgaXNHYWlubWFwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRMb2FkZXIoZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IGxvYWRlciA9IGV4dGVuc2lvbiA9PT0gJ2N1YmUnID8gQ3ViZVRleHR1cmVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdoZHInID8gUkdCRUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2V4cicgPyBFWFJMb2FkZXIgOiBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnID8gSERSSlBHTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnd2VicCcgPyBHYWluTWFwTG9hZGVyIDogbnVsbDtcbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZXhwb3J0IHsgdXNlRW52aXJvbm1lbnQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0IiLCJzb3VyY2VzIjpbIkM6XFxqc3Byb2pcXHJlYWN0LWxhcnR6XFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZHJlaVxcaGVscGVyc1xcZW52aXJvbm1lbnQtYXNzZXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByZXNldHNPYmogPSB7XG4gIGFwYXJ0bWVudDogJ2xlYm9tYm9fMWsuaGRyJyxcbiAgY2l0eTogJ3BvdHNkYW1lcl9wbGF0el8xay5oZHInLFxuICBkYXduOiAna2lhcmFfMV9kYXduXzFrLmhkcicsXG4gIGZvcmVzdDogJ2ZvcmVzdF9zbG9wZV8xay5oZHInLFxuICBsb2JieTogJ3N0X2ZhZ2Fuc19pbnRlcmlvcl8xay5oZHInLFxuICBuaWdodDogJ2Rpa2hvbG9sb19uaWdodF8xay5oZHInLFxuICBwYXJrOiAncm9vaXRvdV9wYXJrXzFrLmhkcicsXG4gIHN0dWRpbzogJ3N0dWRpb19zbWFsbF8wM18xay5oZHInLFxuICBzdW5zZXQ6ICd2ZW5pY2Vfc3Vuc2V0XzFrLmhkcicsXG4gIHdhcmVob3VzZTogJ2VtcHR5X3dhcmVob3VzZV8wMV8xay5oZHInXG59O1xuXG5leHBvcnQgeyBwcmVzZXRzT2JqIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useStore),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useThree),\n/* harmony export */   D: () => (/* binding */ useFrame),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useGraph),\n/* harmony export */   G: () => (/* binding */ useLoader),\n/* harmony export */   _: () => (/* binding */ _roots),\n/* harmony export */   a: () => (/* binding */ useMutableCallback),\n/* harmony export */   b: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   c: () => (/* binding */ createRoot),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createPointerEvents),\n/* harmony export */   g: () => (/* binding */ createEvents),\n/* harmony export */   h: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ addEffect),\n/* harmony export */   k: () => (/* binding */ addAfterEffect),\n/* harmony export */   l: () => (/* binding */ addTail),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ createPortal),\n/* harmony export */   p: () => (/* binding */ flushSync),\n/* harmony export */   q: () => (/* binding */ context),\n/* harmony export */   r: () => (/* binding */ reconciler),\n/* harmony export */   s: () => (/* binding */ applyProps),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useBridge),\n/* harmony export */   v: () => (/* binding */ getRootState),\n/* harmony export */   w: () => (/* binding */ dispose),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ useInstanceHandle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\n/**\r\n * Returns the instance's initial (outmost) root.\r\n */\nfunction findInitialRoot(instance) {\n  let root = instance.root;\n  while (root.getState().previousRoot) root = root.getState().previousRoot;\n  return root;\n}\n/**\r\n * Safely flush async effects when testing, simulating a legacy root.\r\n * @deprecated Import from React instead. import { act } from 'react'\r\n */\n// Reference with computed key to break Webpack static analysis\n// https://github.com/webpack/webpack/issues/14814\nconst act = react__WEBPACK_IMPORTED_MODULE_0__['act' + ''];\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\nconst isColorRepresentation = value => value != null && (typeof value === 'string' || typeof value === 'number' || value.isColor);\n\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */\nconst useIsomorphicLayoutEffect = /* @__PURE__ */((_window$document, _window$navigator) => typeof window !== 'undefined' && (((_window$document = window.document) == null ? void 0 : _window$document.createElement) || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative'))() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\n/**\r\n * Bridges renderer Context and StrictMode from a primary renderer.\r\n */\nfunction useBridge() {\n  const fiber = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useFiber)();\n  const ContextBridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useContextBridge)();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    children\n  }) => {\n    const strict = !!(0,its_fine__WEBPACK_IMPORTED_MODULE_5__.traverseFiber)(fiber, true, node => node.type === react__WEBPACK_IMPORTED_MODULE_0__.StrictMode);\n    const Root = strict ? react__WEBPACK_IMPORTED_MODULE_0__.StrictMode : react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ContextBridge, {\n        children: children\n      })\n    });\n  }, [fiber, ContextBridge]);\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\n\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */(_ErrorBoundary => (_ErrorBoundary = class ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}, _ErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n}), _ErrorBoundary))();\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\r\n * Returns instance root state\r\n */\nfunction getRootState(obj) {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n}\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  nul: a => a === null,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {},\n    meshes: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n      if (obj.isMesh && !data.meshes[obj.name]) data.meshes[obj.name] = obj;\n    });\n  }\n  return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.type !== 'Scene') obj.dispose == null ? void 0 : obj.dispose();\n  for (const p in obj) {\n    const prop = obj[p];\n    if ((prop == null ? void 0 : prop.type) !== 'Scene') prop == null ? void 0 : prop.dispose == null ? void 0 : prop.dispose();\n  }\n}\nconst REACT_INTERNAL_PROPS = ['children', 'key', 'ref'];\n\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n  const props = {};\n  for (const key in queue) {\n    if (!REACT_INTERNAL_PROPS.includes(key)) props[key] = queue[key];\n  }\n  return props;\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n  const object = target;\n\n  // Create instance descriptor\n  let instance = object == null ? void 0 : object.__r3f;\n  if (!instance) {\n    instance = {\n      root,\n      type,\n      parent: null,\n      children: [],\n      props: getInstanceProps(props),\n      object,\n      eventCount: 0,\n      handlers: {},\n      isHidden: false\n    };\n    if (object) object.__r3f = instance;\n  }\n  return instance;\n}\nfunction resolve(root, key) {\n  let target = root[key];\n  if (!key.includes('-')) return {\n    root,\n    key,\n    target\n  };\n\n  // Resolve pierced target\n  target = root;\n  for (const part of key.split('-')) {\n    var _target;\n    key = part;\n    root = target;\n    target = (_target = target) == null ? void 0 : _target[key];\n  }\n\n  // TODO: change key to 'foo-bar' if target is undefined?\n\n  return {\n    root,\n    key,\n    target\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n  if (is.str(child.props.attach)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(child.props.attach)) {\n      const index = child.props.attach.replace(INDEX_REGEX, '');\n      const {\n        root,\n        key\n      } = resolve(parent.object, index);\n      if (!Array.isArray(root[key])) root[key] = [];\n    }\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    child.previousAttach = root[key];\n    root[key] = child.object;\n  } else if (is.fun(child.props.attach)) {\n    child.previousAttach = child.props.attach(parent.object, child.object);\n  }\n}\nfunction detach(parent, child) {\n  if (is.str(child.props.attach)) {\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    const previous = child.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete root[key];\n    // Otherwise set the previous value\n    else root[key] = previous;\n  } else {\n    child.previousAttach == null ? void 0 : child.previousAttach(parent.object, child.object);\n  }\n  delete child.previousAttach;\n}\nconst RESERVED_PROPS = [...REACT_INTERNAL_PROPS,\n// Instance props\n'args', 'dispose', 'attach', 'object', 'onUpdate',\n// Behavior flags\n'dispose'];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n  let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n  try {\n    if (!ctor) {\n      ctor = new root.constructor();\n      MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n    }\n  } catch (e) {\n    // ...\n  }\n  return ctor;\n}\n\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n  const changedProps = {};\n\n  // Sort through props\n  for (const prop in newProps) {\n    // Skip reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n    // Skip if props match\n    if (is.equ(newProps[prop], instance.props[prop])) continue;\n\n    // Props changed, add them\n    changedProps[prop] = newProps[prop];\n\n    // Reset pierced props\n    for (const other in newProps) {\n      if (other.startsWith(`${prop}-`)) changedProps[other] = newProps[other];\n    }\n  }\n\n  // Reset removed props for HMR\n  for (const prop in instance.props) {\n    if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop)) continue;\n    const {\n      root,\n      key\n    } = resolve(instance.object, prop);\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (root.constructor && root.constructor.length === 0) {\n      // create a blank slate of the instance and copy the particular parameter.\n      const ctor = getMemoizedPrototype(root);\n      if (!is.und(ctor)) changedProps[key] = ctor[key];\n    } else {\n      // instance does not have constructor, just set it to 0\n      changedProps[key] = 0;\n    }\n  }\n  return changedProps;\n}\n\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = ['map', 'emissiveMap', 'sheenColorMap', 'specularColorMap', 'envMap'];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n  var _instance$object;\n  const instance = object.__r3f;\n  const rootState = instance && findInitialRoot(instance).getState();\n  const prevHandlers = instance == null ? void 0 : instance.eventCount;\n  for (const prop in props) {\n    let value = props[prop];\n\n    // Don't mutate reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n\n    // Deal with pointer events, including removing them if undefined\n    if (instance && EVENT_REGEX.test(prop)) {\n      if (typeof value === 'function') instance.handlers[prop] = value;else delete instance.handlers[prop];\n      instance.eventCount = Object.keys(instance.handlers).length;\n      continue;\n    }\n\n    // Ignore setting undefined props\n    // https://github.com/pmndrs/react-three-fiber/issues/274\n    if (value === undefined) continue;\n    let {\n      root,\n      key,\n      target\n    } = resolve(object, prop);\n\n    // Layers must be written to the mask property\n    if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers) {\n      target.mask = value.mask;\n    }\n    // Set colors if valid color representation for automatic conversion (copy)\n    else if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Color && isColorRepresentation(value)) {\n      target.set(value);\n    }\n    // Copy if properties match signatures and implement math interface (likely read-only)\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof target.copy === 'function' && value != null && value.constructor && target.constructor === value.constructor) {\n      target.copy(value);\n    }\n    // Set array types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && Array.isArray(value)) {\n      if (typeof target.fromArray === 'function') target.fromArray(value);else target.set(...value);\n    }\n    // Set literal types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof value === 'number') {\n      // Allow setting array scalars\n      if (typeof target.setScalar === 'function') target.setScalar(value);\n      // Otherwise just set single value\n      else target.set(value);\n    }\n    // Else, just overwrite the value\n    else {\n      var _root$key;\n      root[key] = value;\n\n      // Auto-convert sRGB texture parameters for built-in materials\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      // https://github.com/mrdoob/three.js/pull/25857\n      if (rootState && !rootState.linear && colorMaps.includes(key) && (_root$key = root[key]) != null && _root$key.isTexture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      root[key].format === three__WEBPACK_IMPORTED_MODULE_6__.RGBAFormat && root[key].type === three__WEBPACK_IMPORTED_MODULE_6__.UnsignedByteType) {\n        // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n        root[key].colorSpace = three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n      }\n    }\n  }\n\n  // Register event handlers\n  if (instance != null && instance.parent && rootState != null && rootState.internal && (_instance$object = instance.object) != null && _instance$object.isObject3D && prevHandlers !== instance.eventCount) {\n    const object = instance.object;\n    // Pre-emptively remove the instance from the interaction manager\n    const index = rootState.internal.interaction.indexOf(object);\n    if (index > -1) rootState.internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (instance.eventCount && object.raycast !== null) {\n      rootState.internal.interaction.push(object);\n    }\n  }\n\n  // Auto-attach geometries and materials\n  if (instance && instance.props.attach === undefined) {\n    if (instance.object.isBufferGeometry) instance.props.attach = 'geometry';else if (instance.object.isMaterial) instance.props.attach = 'material';\n  }\n\n  // Instance was updated, request a frame\n  if (instance) invalidateInstance(instance);\n  return object;\n}\nfunction invalidateInstance(instance) {\n  var _instance$root;\n  if (!instance.parent) return;\n  instance.props.onUpdate == null ? void 0 : instance.props.onUpdate(instance.object);\n  const state = (_instance$root = instance.root) == null ? void 0 : _instance$root.getState == null ? void 0 : _instance$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateCamera(camera, size) {\n  // Do not mess with the camera if it belongs to the user\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  if (camera.manual) return;\n  if (isOrthographicCamera(camera)) {\n    camera.left = size.width / -2;\n    camera.right = size.width / 2;\n    camera.top = size.height / 2;\n    camera.bottom = size.height / -2;\n  } else {\n    camera.aspect = size.width / size.height;\n  }\n  camera.updateProjectionMatrix();\n}\nconst isObject3D = object => object == null ? void 0 : object.isObject3D;\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        let state = getRootState(hit.object);\n\n        // If the object is not managed by R3F, it might be parented to an element which is.\n        // Traverse upwards until we find a managed parent and use its state instead.\n        if (!state) {\n          hit.object.traverseAncestors(obj => {\n            const parentState = getRootState(obj);\n            if (parentState) {\n              state = parentState;\n              return false;\n            }\n          });\n        }\n        if (state) {\n          const {\n            raycaster,\n            pointer,\n            camera,\n            internal\n          } = state;\n          const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n          const hasPointerCapture = id => {\n            var _internal$capturedMap, _internal$capturedMap2;\n            return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n          };\n          const setPointerCapture = id => {\n            const captureData = {\n              intersection: hit,\n              target: event.target\n            };\n            if (internal.capturedMap.has(id)) {\n              // if the pointerId was previously captured, we add the hit to the\n              // event capturedMap.\n              internal.capturedMap.get(id).set(hit.eventObject, captureData);\n            } else {\n              // if the pointerId was not previously captured, we create a map\n              // containing the hitObject, and the hit. hitObject is used for\n              // faster access.\n              internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n            }\n            event.target.setPointerCapture(id);\n          };\n          const releasePointerCapture = id => {\n            const captures = internal.capturedMap.get(id);\n            if (captures) {\n              releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n            }\n          };\n\n          // Add native event props\n          let extractEventProps = {};\n          // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n          for (let prop in event) {\n            let property = event[prop];\n            // Only copy over atomics, leave functions alone as these should be\n            // called as event.nativeEvent.fn()\n            if (typeof property !== 'function') extractEventProps[prop] = property;\n          }\n          let raycastEvent = {\n            ...hit,\n            ...extractEventProps,\n            pointer,\n            intersections,\n            stopped: localState.stopped,\n            delta,\n            unprojectedPoint,\n            ray: raycaster.ray,\n            camera: camera,\n            // Hijack stopPropagation, which just sets a flag\n            stopPropagation() {\n              // https://github.com/pmndrs/react-three-fiber/issues/596\n              // Events are not allowed to stop propagation if the pointer has been captured\n              const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n              // We only authorize stopPropagation...\n              if (\n              // ...if this pointer hasn't been captured\n              !capturesForPointer ||\n              // ... or if the hit object is capturing the pointer\n              capturesForPointer.has(hit.eventObject)) {\n                raycastEvent.stopped = localState.stopped = true;\n                // Propagation is stopped, remove all other hover records\n                // An event handler is only allowed to flush other handlers if it is hovered itself\n                if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                  // Objects cannot flush out higher up objects that have already caught the event\n                  const higher = intersections.slice(0, intersections.indexOf(hit));\n                  cancelPointer([...higher, hit]);\n                }\n              }\n            },\n            // there should be a distinction between target and currentTarget\n            target: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            currentTarget: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            nativeEvent: event\n          };\n\n          // Call subscribers\n          callback(raycastEvent);\n          // Event bubbling may be interrupted by stopPropagation\n          if (localState.stopped === true) break;\n        }\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          const handlers = instance.handlers;\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n        const handlers = instance.handlers;\n\n        /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => {\n    const position = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const tempTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target.isVector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      scene: null,\n      xr: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new three__WEBPACK_IMPORTED_MODULE_6__.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, top = 0, left = 0) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top,\n          left\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        // Events\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        lastEvent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n        // Updates\n        active: false,\n        frames: 0,\n        priority: 0,\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootStore.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootStore.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootStore.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      if (viewport.dpr > 0) gl.setPixelRatio(viewport.dpr);\n      const updateStyle = typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootStore.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootStore;\n};\n\n/**\r\n * Exposes an object's {@link Instance}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */\nfunction useInstanceHandle(ref) {\n  const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(instance, () => ref.current.__r3f, [ref]);\n  return instance;\n}\n\n/**\r\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\r\n */\nfunction useStore() {\n  const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */\nfunction useGraph(object) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = value => {\n  var _value$prototype;\n  return typeof value === 'function' && (value == null ? void 0 : (_value$prototype = value.prototype) == null ? void 0 : _value$prototype.constructor) === value;\n};\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    let loader;\n\n    // Construct and cache loader if constructor was passed\n    if (isConstructor$1(Proto)) {\n      loader = memoizedLoaders.get(Proto);\n      if (!loader) {\n        loader = new Proto();\n        memoizedLoaders.set(Proto, loader);\n      }\n    } else {\n      loader = Proto;\n    }\n\n    // Apply loader extensions\n    if (extensions) extensions(loader);\n\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (isObject3D(data == null ? void 0 : data.scene)) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n  };\n}\n\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */\nfunction useLoader(loader, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.suspend)(loadingFn(extensions, onProgress), [loader, ...keys], {\n    equal: is.equ\n  });\n  // Return the object(s)\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */\nuseLoader.preload = function (loader, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.preload)(loadingFn(extensions), [loader, ...keys]);\n};\n\n/**\r\n * Removes a loaded asset from cache.\r\n */\nuseLoader.clear = function (loader, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.clear)([loader, ...keys]);\n};\n\nfunction createReconciler(config) {\n  const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()(config);\n  reconciler.injectIntoDevTools({\n    bundleType: typeof process !== 'undefined' && \"development\" !== 'production' ? 1 : 0,\n    rendererPackageName: '@react-three/fiber',\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n  });\n  return reconciler;\n}\nconst NoEventPriority = 0;\n\n// TODO: handle constructor overloads\n// https://github.com/pmndrs/react-three-fiber/pull/2931\n// https://github.com/microsoft/TypeScript/issues/37079\n\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = type => `${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = object => typeof object === 'function';\nfunction extend(objects) {\n  if (isConstructor(objects)) {\n    const Component = `${i++}`;\n    catalogue[Component] = objects;\n    return Component;\n  } else {\n    Object.assign(catalogue, objects);\n  }\n}\nfunction validateInstance(type, props) {\n  // Get target from catalogue\n  const name = toPascalCase(type);\n  const target = catalogue[name];\n\n  // Validate element target\n  if (type !== 'primitive' && !target) throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n\n  // Validate primitives\n  if (type === 'primitive' && !props.object) throw new Error(`R3F: Primitives without 'object' are invalid!`);\n\n  // Throw if an object or literal was passed for args\n  if (props.args !== undefined && !Array.isArray(props.args)) throw new Error('R3F: The args prop must be an array!');\n}\nfunction createInstance(type, props, root) {\n  var _props$object;\n  // Remove three* prefix from elements if native element not present\n  type = toPascalCase(type) in catalogue ? type : type.replace(PREFIX_REGEX, '');\n  validateInstance(type, props);\n\n  // Regenerate the R3F instance for primitives to simulate a new object\n  if (type === 'primitive' && (_props$object = props.object) != null && _props$object.__r3f) delete props.object.__r3f;\n  return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n  if (!instance.isHidden) {\n    var _instance$parent;\n    if (instance.props.attach && (_instance$parent = instance.parent) != null && _instance$parent.object) {\n      detach(instance.parent, instance);\n    } else if (isObject3D(instance.object)) {\n      instance.object.visible = false;\n    }\n    instance.isHidden = true;\n    invalidateInstance(instance);\n  }\n}\nfunction unhideInstance(instance) {\n  if (instance.isHidden) {\n    var _instance$parent2;\n    if (instance.props.attach && (_instance$parent2 = instance.parent) != null && _instance$parent2.object) {\n      attach(instance.parent, instance);\n    } else if (isObject3D(instance.object) && instance.props.visible !== false) {\n      instance.object.visible = true;\n    }\n    instance.isHidden = false;\n    invalidateInstance(instance);\n  }\n}\n\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n  // Bail if tree isn't mounted or parent is not a container.\n  // This ensures that the tree is finalized and React won't discard results to Suspense\n  const state = child.root.getState();\n  if (!parent.parent && parent.object !== state.scene) return;\n\n  // Create & link object on first run\n  if (!child.object) {\n    var _child$props$object, _child$props$args;\n    // Get target from catalogue\n    const target = catalogue[toPascalCase(child.type)];\n\n    // Create object\n    child.object = (_child$props$object = child.props.object) != null ? _child$props$object : new target(...((_child$props$args = child.props.args) != null ? _child$props$args : []));\n    child.object.__r3f = child;\n  }\n\n  // Set initial props\n  applyProps(child.object, child.props);\n\n  // Append instance\n  if (child.props.attach) {\n    attach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    const childIndex = parent.object.children.indexOf(beforeChild == null ? void 0 : beforeChild.object);\n    if (beforeChild && childIndex !== -1) {\n      // If the child is already in the parent's children array, move it to the new position\n      // Otherwise, just insert it at the target position\n      const existingIndex = parent.object.children.indexOf(child.object);\n      if (existingIndex !== -1) {\n        parent.object.children.splice(existingIndex, 1);\n        const adjustedIndex = existingIndex < childIndex ? childIndex - 1 : childIndex;\n        parent.object.children.splice(adjustedIndex, 0, child.object);\n      } else {\n        child.object.parent = parent.object;\n        parent.object.children.splice(childIndex, 0, child.object);\n        child.object.dispatchEvent({\n          type: 'added'\n        });\n        parent.object.dispatchEvent({\n          type: 'childadded',\n          child: child.object\n        });\n      }\n    } else {\n      parent.object.add(child.object);\n    }\n  }\n\n  // Link subtree\n  for (const childInstance of child.children) handleContainerEffects(child, childInstance);\n\n  // Tree was updated, request a frame\n  invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n  if (!child) return;\n\n  // Link instances\n  child.parent = parent;\n  parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n  if (!child || !beforeChild) return;\n\n  // Link instances\n  child.parent = parent;\n  const childIndex = parent.children.indexOf(beforeChild);\n  if (childIndex !== -1) parent.children.splice(childIndex, 0, child);else parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n  if (typeof object.dispose === 'function') {\n    const handleDispose = () => {\n      try {\n        object.dispose();\n      } catch {\n        // no-op\n      }\n    };\n\n    // In a testing environment, cleanup immediately\n    if (typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined') handleDispose();\n    // Otherwise, using a real GPU so schedule cleanup to prevent stalls\n    else (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, handleDispose);\n  }\n}\nfunction removeChild(parent, child, dispose) {\n  if (!child) return;\n\n  // Unlink instances\n  child.parent = null;\n  const childIndex = parent.children.indexOf(child);\n  if (childIndex !== -1) parent.children.splice(childIndex, 1);\n\n  // Eagerly tear down tree\n  if (child.props.attach) {\n    detach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    parent.object.remove(child.object);\n    removeInteractivity(findInitialRoot(child), child.object);\n  }\n\n  // Allow objects to bail out of unmount disposal with dispose={null}\n  const shouldDispose = child.props.dispose !== null && dispose !== false;\n\n  // Recursively remove instance children\n  for (let i = child.children.length - 1; i >= 0; i--) {\n    const node = child.children[i];\n    removeChild(child, node, shouldDispose);\n  }\n  child.children.length = 0;\n\n  // Unlink instance object\n  delete child.object.__r3f;\n\n  // Dispose object whenever the reconciler feels like it.\n  // Never dispose of primitives because their state may be kept outside of React!\n  // In order for an object to be able to dispose it\n  //   - has a dispose method\n  //   - cannot be a <primitive object={...} />\n  //   - cannot be a THREE.Scene, because three has broken its own API\n  if (shouldDispose && child.type !== 'primitive' && child.object.type !== 'Scene') {\n    disposeOnIdle(child.object);\n  }\n\n  // Tree was updated, request a frame for top-level instance\n  if (dispose === undefined) invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n  for (const _fiber of [fiber, fiber.alternate]) {\n    if (_fiber !== null) {\n      if (typeof _fiber.ref === 'function') {\n        _fiber.refCleanup == null ? void 0 : _fiber.refCleanup();\n        const cleanup = _fiber.ref(publicInstance);\n        if (typeof cleanup === 'function') _fiber.refCleanup = cleanup;\n      } else if (_fiber.ref) {\n        _fiber.ref.current = publicInstance;\n      }\n    }\n  }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n  // Detach instance\n  for (const [instance] of reconstructed) {\n    const parent = instance.parent;\n    if (parent) {\n      if (instance.props.attach) {\n        detach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.remove(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          detach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.remove(child.object);\n        }\n      }\n    }\n\n    // If the old instance is hidden, we need to unhide it.\n    // React assumes it can discard instances since they're pure for DOM.\n    // This isn't true for us since our lifetimes are impure and longliving.\n    // So, we manually check if an instance was hidden and unhide it.\n    if (instance.isHidden) unhideInstance(instance);\n\n    // Dispose of old object if able\n    if (instance.object.__r3f) delete instance.object.__r3f;\n    if (instance.type !== 'primitive') disposeOnIdle(instance.object);\n  }\n\n  // Update instance\n  for (const [instance, props, fiber] of reconstructed) {\n    instance.props = props;\n    const parent = instance.parent;\n    if (parent) {\n      var _instance$props$objec, _instance$props$args;\n      // Get target from catalogue\n      const target = catalogue[toPascalCase(instance.type)];\n\n      // Create object\n      instance.object = (_instance$props$objec = instance.props.object) != null ? _instance$props$objec : new target(...((_instance$props$args = instance.props.args) != null ? _instance$props$args : []));\n      instance.object.__r3f = instance;\n      setFiberRef(fiber, instance.object);\n\n      // Set initial props\n      applyProps(instance.object, instance.props);\n      if (instance.props.attach) {\n        attach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.add(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          attach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.add(child.object);\n        }\n      }\n\n      // Tree was updated, request a frame\n      invalidateInstance(instance);\n    }\n  }\n  reconstructed.length = 0;\n}\n\n// Don't handle text instances, make it no-op\nconst handleTextInstance = () => {};\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */createReconciler({\n  isPrimaryRenderer: false,\n  warnsIfNotActing: false,\n  supportsMutation: true,\n  supportsPersistence: false,\n  supportsHydration: false,\n  createInstance,\n  removeChild,\n  appendChild,\n  appendInitialChild: appendChild,\n  insertBefore,\n  appendChildToContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    appendChild(scene, child);\n  },\n  removeChildFromContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    removeChild(scene, child);\n  },\n  insertInContainerBefore(container, child, beforeChild) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !beforeChild || !scene) return;\n    insertBefore(scene, child, beforeChild);\n  },\n  getRootHostContext: () => NO_CONTEXT,\n  getChildHostContext: () => NO_CONTEXT,\n  commitUpdate(instance, type, oldProps, newProps, fiber) {\n    var _newProps$args, _oldProps$args, _newProps$args2;\n    validateInstance(type, newProps);\n    let reconstruct = false;\n\n    // Reconstruct primitives if object prop changes\n    if (instance.type === 'primitive' && oldProps.object !== newProps.object) reconstruct = true;\n    // Reconstruct instance if args were added or removed\n    else if (((_newProps$args = newProps.args) == null ? void 0 : _newProps$args.length) !== ((_oldProps$args = oldProps.args) == null ? void 0 : _oldProps$args.length)) reconstruct = true;\n    // Reconstruct instance if args were changed\n    else if ((_newProps$args2 = newProps.args) != null && _newProps$args2.some((value, index) => {\n      var _oldProps$args2;\n      return value !== ((_oldProps$args2 = oldProps.args) == null ? void 0 : _oldProps$args2[index]);\n    })) reconstruct = true;\n\n    // Reconstruct when args or <primitive object={...} have changes\n    if (reconstruct) {\n      reconstructed.push([instance, {\n        ...newProps\n      }, fiber]);\n    } else {\n      // Create a diff-set, flag if there are any changes\n      const changedProps = diffProps(instance, newProps);\n      if (Object.keys(changedProps).length) {\n        Object.assign(instance.props, changedProps);\n        applyProps(instance.object, changedProps);\n      }\n    }\n\n    // Flush reconstructed siblings when we hit the last updated child in a sequence\n    const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n    if (isTailSibling) swapInstances();\n  },\n  finalizeInitialChildren: () => false,\n  commitMount() {},\n  getPublicInstance: instance => instance == null ? void 0 : instance.object,\n  prepareForCommit: () => null,\n  preparePortalMount: container => prepare(container.getState().scene, container, '', {}),\n  resetAfterCommit: () => {},\n  shouldSetTextContent: () => false,\n  clearContainer: () => false,\n  hideInstance,\n  unhideInstance,\n  createTextInstance: handleTextInstance,\n  hideTextInstance: handleTextInstance,\n  unhideTextInstance: handleTextInstance,\n  scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n  cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n  noTimeout: -1,\n  getInstanceFromNode: () => null,\n  beforeActiveInstanceBlur() {},\n  afterActiveInstanceBlur() {},\n  detachDeletedInstance() {},\n  prepareScopeUpdate() {},\n  getInstanceFromScope: () => null,\n  shouldAttemptEagerTransition: () => false,\n  trackSchedulerEvent: () => {},\n  resolveEventType: () => null,\n  resolveEventTimeStamp: () => -1.1,\n  requestPostPaintCallback() {},\n  maySuspendCommit: () => false,\n  preloadInstance: () => true,\n  // true indicates already loaded\n  startSuspendingCommit() {},\n  suspendInstance() {},\n  waitForCommitToBeReady: () => null,\n  NotPendingTransition: null,\n  // The reconciler types use the internal ReactContext with all the hidden properties\n  // so we have to cast from the public React.Context type\n  HostTransitionContext: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),\n  setCurrentUpdatePriority(newPriority) {\n    currentUpdatePriority = newPriority;\n  },\n  getCurrentUpdatePriority() {\n    return currentUpdatePriority;\n  },\n  resolveUpdatePriority() {\n    var _window$event;\n    if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority;\n    switch (typeof window !== 'undefined' && ((_window$event = window.event) == null ? void 0 : _window$event.type)) {\n      case 'click':\n      case 'contextmenu':\n      case 'dblclick':\n      case 'pointercancel':\n      case 'pointerdown':\n      case 'pointerup':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n      case 'pointermove':\n      case 'pointerout':\n      case 'pointerover':\n      case 'pointerenter':\n      case 'pointerleave':\n      case 'wheel':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n      default:\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n  },\n  resetFormInstance() {}\n});\n\nconst _roots = new Map();\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nfunction computeInitialSize(canvas, size) {\n  if (!size && typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left\n    };\n  } else if (!size && typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    ...size\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = _roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store,\n  // container\n  react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot,\n  // tag\n  null,\n  // hydration callbacks\n  false,\n  // isStrictMode\n  null,\n  // concurrentUpdatesByDefaultOverride\n  '',\n  // identifierPrefix\n  logRecoverableError,\n  // onUncaughtError\n  logRecoverableError,\n  // onCaughtError\n  logRecoverableError,\n  // onRecoverableError\n  null // transitionCallbacks\n  );\n  // Map it\n  if (!prevRoot) _roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let lastCamera;\n  let configured = false;\n  let pending = null;\n  return {\n    async configure(props = {}) {\n      let resolve;\n      pending = new Promise(_resolve => resolve = _resolve);\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) {\n        const defaultProps = {\n          canvas: canvas,\n          powerPreference: 'high-performance',\n          antialias: true,\n          alpha: true\n        };\n        const customRenderer = typeof glConfig === 'function' ? await glConfig(defaultProps) : glConfig;\n        if (isRenderer(customRenderer)) {\n          gl = customRenderer;\n        } else {\n          gl = new three__WEBPACK_IMPORTED_MODULE_6__.WebGLRenderer({\n            ...defaultProps,\n            ...glConfig\n          });\n        }\n        state.set({\n          gl\n        });\n      }\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions == null ? void 0 : cameraOptions.isCamera;\n        const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_6__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) {\n            applyProps(camera, cameraOptions);\n            // Preserve user-defined frustum if possible\n            // https://github.com/pmndrs/react-three-fiber/issues/3160\n            if (!camera.manual) {\n              if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n                camera.manual = true;\n                camera.updateProjectionMatrix();\n              }\n            }\n          }\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions != null && sceneOptions.isScene) {\n          scene = sceneOptions;\n          prepare(scene, store, '', {});\n        } else {\n          scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();\n          prepare(scene, store, '', {});\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene\n        });\n      }\n\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: three__WEBPACK_IMPORTED_MODULE_6__.BasicShadowMap,\n            percentage: three__WEBPACK_IMPORTED_MODULE_6__.PCFShadowMap,\n            soft: three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap,\n            variance: three__WEBPACK_IMPORTED_MODULE_6__.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n      three__WEBPACK_IMPORTED_MODULE_6__.ColorManagement.enabled = !legacy;\n\n      // Set color space and tonemapping preferences\n      if (!configured) {\n        gl.outputColorSpace = linear ? three__WEBPACK_IMPORTED_MODULE_6__.LinearSRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n        gl.toneMapping = flat ? three__WEBPACK_IMPORTED_MODULE_6__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_6__.ACESFilmicToneMapping;\n      }\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      resolve();\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured && !pending) this.configure();\n      pending.then(() => {\n        reconciler.updateContainer( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n          store: store,\n          children: children,\n          onCreated: onCreated,\n          rootElement: canvas\n        }), fiber, null, () => undefined);\n      });\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notify that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n    value: store,\n    children: children\n  });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = _roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state.scene);\n            _roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n    children: children,\n    container: container,\n    state: state\n  });\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster());\n  const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Vector2());\n  const inject = useMutableCallback((rootState, injectState) => {\n    let viewport = undefined;\n    if (injectState.camera && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...rootState,\n      ...injectState,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...injectState.events,\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      // Layers are allowed to override events\n      setEvents: events => injectState.set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    };\n  });\n  const usePortalStore = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const store = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => ({\n      ...rest,\n      set,\n      get\n    }));\n\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const onMutate = prev => store.setState(state => inject.current(prev, state));\n    onMutate(previousRoot.getState());\n    previousRoot.subscribe(onMutate);\n    return store;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [previousRoot, container]);\n  return (\n    /*#__PURE__*/\n    // @ts-ignore, reconciler types are not maintained\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n      children: reconciler.createPortal( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n        value: usePortalStore,\n        children: children\n      }), usePortalStore, null)\n    })\n  );\n}\n\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution. Note: this will only flush updates within the `Canvas` root.\r\n */\nfunction flushSync(fn) {\n  // @ts-ignore - reconciler types are not maintained\n  return reconciler.flushSyncFromReconciler(fn);\n}\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (let i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n  frame = requestAnimationFrame(loop);\n  running = true;\n  repeat = 0;\n\n  // Run effects\n  flushGlobalEffects('before', timestamp);\n\n  // Render all roots\n  useFrameInProgress = true;\n  for (const root of _roots.values()) {\n    var _state$gl$xr;\n    state = root.store.getState();\n\n    // If the frameloop is invalidated, do not run another frame\n    if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n      repeat += update(timestamp, state);\n    }\n  }\n  useFrameInProgress = false;\n\n  // Run after-effects\n  flushGlobalEffects('after', timestamp);\n\n  // Stop the loop if nothing invalidates it\n  if (repeat === 0) {\n    // Tail call effects, they are called when rendering stops\n    flushGlobalEffects('tail', timestamp);\n\n    // Flag end of operation\n    running = false;\n    return cancelAnimationFrame(frame);\n  }\n}\n\n/**\r\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\r\n */\nfunction invalidate(state, frames = 1) {\n  var _state$gl$xr2;\n  if (!state) return _roots.forEach(root => invalidate(root.store.getState(), frames));\n  if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n  if (frames > 1) {\n    // legacy support for people using frames parameters\n    // Increase frames, do not go higher than 60\n    state.internal.frames = Math.min(60, state.internal.frames + frames);\n  } else {\n    if (useFrameInProgress) {\n      //called from within a useFrame, it means the user wants an additional frame\n      state.internal.frames = 2;\n    } else {\n      //the user need a new frame, no need to increment further than 1\n      state.internal.frames = 1;\n    }\n  }\n\n  // If the render-loop isn't active, start it\n  if (!running) {\n    running = true;\n    requestAnimationFrame(loop);\n  }\n}\n\n/**\r\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\r\n */\nfunction advance(timestamp, runGlobalEffects = true, state, frame) {\n  if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n  if (!state) for (const root of _roots.values()) update(timestamp, root.store.getState());else update(timestamp, state, frame);\n  if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n}\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      if (events.handlers) {\n        for (const name in events.handlers) {\n          const event = events.handlers[name];\n          const [eventName, passive] = DOM_EVENTS[name];\n          target.addEventListener(eventName, event, {\n            passive\n          });\n        }\n      }\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        if (events.handlers) {\n          for (const name in events.handlers) {\n            const event = events.handlers[name];\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        }\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLWUzY2I2NmUyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ21HO0FBQ25HO0FBQzRCO0FBQ0g7QUFDZDtBQUNtQztBQUMzQjtBQUNtQjs7QUFFckU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFLO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1VUFBdVUsa0RBQXFCLEdBQUcsNENBQWU7QUFDOVc7QUFDQSxjQUFjLHlDQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFRO0FBQ3hCLHdCQUF3QiwwREFBZ0I7QUFDeEMsU0FBUywwQ0FBYTtBQUN0QjtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsdURBQWEsb0NBQW9DLDZDQUFnQjtBQUN0RiwwQkFBMEIsNkNBQWdCLEdBQUcsMkNBQWM7QUFDM0Qsd0JBQXdCLHNEQUFHO0FBQzNCLDZCQUE2QixzREFBRztBQUNoQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHNHQUFzRyw0Q0FBZTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSwwQkFBMEIseUNBQVkscUJBQXFCLHlDQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFnQix1QkFBdUIsbURBQXNCO0FBQ3hGO0FBQ0EsK0JBQStCLGlEQUFvQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFX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RUE7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHdGQUF3RjtBQUN4Riw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnREFBbUI7QUFDM0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2RUFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrRUFBdUI7QUFDdEM7QUFDQSxlQUFlLDRFQUFvQjtBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbUJBQW1CLGdEQUFtQjtBQUN0QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQWU7QUFDbEQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFEQUF3Qiw4QkFBOEIsb0RBQXVCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxVQUFVO0FBQ1Ysc0JBQXNCLHdDQUFXO0FBQ2pDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFzQjtBQUNwRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1CQUFtQixpREFBb0I7QUFDdkMsd0JBQXdCLCtDQUFrQjtBQUMxQyxrQkFBa0IsbURBQXNCO0FBQ3hDLHNCQUFzQiwrQ0FBa0I7QUFDeEM7QUFDQSwyRkFBMkYsbURBQXNCO0FBQ2pILFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0RBQXFCOztBQUUzQjtBQUNBO0FBQ0EsdUNBQXVDLHVEQUEwQixHQUFHLGlEQUFvQjtBQUN4RixnQ0FBZ0MsZ0RBQW1CLEdBQUcsd0RBQTJCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzREFBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0JBQXNCLDJDQUFjLFdBQVcsNENBQWU7QUFDOUQsb0JBQW9CLDJDQUFjLFdBQVcsMENBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwwQ0FBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwwQ0FBYTtBQUN0QztBQUNBLGtCQUFrQix5RUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBRyxDQUFDLHVEQUFRO0FBQ2hCLHNEQUFzRCxzREFBRztBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVtbUIiLCJzb3VyY2VzIjpbIkM6XFxqc3Byb2pcXHJlYWN0LWxhcnR6XFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXGRpc3RcXGV2ZW50cy1lM2NiNjZlMi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgUmVjb25jaWxlciBmcm9tICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCB7IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssIHVuc3RhYmxlX0lkbGVQcmlvcml0eSB9IGZyb20gJ3NjaGVkdWxlcic7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlRmliZXIsIHVzZUNvbnRleHRCcmlkZ2UsIHRyYXZlcnNlRmliZXIgfSBmcm9tICdpdHMtZmluZSc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2UncyBpbml0aWFsIChvdXRtb3N0KSByb290LlxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkge1xuICBsZXQgcm9vdCA9IGluc3RhbmNlLnJvb3Q7XG4gIHdoaWxlIChyb290LmdldFN0YXRlKCkucHJldmlvdXNSb290KSByb290ID0gcm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG4vKipcclxuICogU2FmZWx5IGZsdXNoIGFzeW5jIGVmZmVjdHMgd2hlbiB0ZXN0aW5nLCBzaW11bGF0aW5nIGEgbGVnYWN5IHJvb3QuXHJcbiAqIEBkZXByZWNhdGVkIEltcG9ydCBmcm9tIFJlYWN0IGluc3RlYWQuIGltcG9ydCB7IGFjdCB9IGZyb20gJ3JlYWN0J1xyXG4gKi9cbi8vIFJlZmVyZW5jZSB3aXRoIGNvbXB1dGVkIGtleSB0byBicmVhayBXZWJwYWNrIHN0YXRpYyBhbmFseXNpc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcbmNvbnN0IGFjdCA9IFJlYWN0WydhY3QnICsgJyddO1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcbmNvbnN0IGlzQ29sb3JSZXByZXNlbnRhdGlvbiA9IHZhbHVlID0+IHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZS5pc0NvbG9yKTtcblxuLyoqXHJcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXHJcbiAqXHJcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXHJcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xyXG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8oKF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSkoKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbi8qKlxyXG4gKiBCcmlkZ2VzIHJlbmRlcmVyIENvbnRleHQgYW5kIFN0cmljdE1vZGUgZnJvbSBhIHByaW1hcnkgcmVuZGVyZXIuXHJcbiAqL1xuZnVuY3Rpb24gdXNlQnJpZGdlKCkge1xuICBjb25zdCBmaWJlciA9IHVzZUZpYmVyKCk7XG4gIGNvbnN0IENvbnRleHRCcmlkZ2UgPSB1c2VDb250ZXh0QnJpZGdlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHN0cmljdCA9ICEhdHJhdmVyc2VGaWJlcihmaWJlciwgdHJ1ZSwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFJlYWN0LlN0cmljdE1vZGUpO1xuICAgIGNvbnN0IFJvb3QgPSBzdHJpY3QgPyBSZWFjdC5TdHJpY3RNb2RlIDogUmVhY3QuRnJhZ21lbnQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm9vdCwge1xuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ29udGV4dEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sIFtmaWJlciwgQ29udGV4dEJyaWRnZV0pO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogc3RhdGljIG1lbWJlcnMgZ2V0IGRvd24tbGV2ZWwgdHJhbnNwaWxlZCB0byBtdXRhdGlvbnMgd2hpY2ggYnJlYWsgdHJlZS1zaGFraW5nXG5jb25zdCBFcnJvckJvdW5kYXJ5ID0gLyogQF9fUFVSRV9fICovKF9FcnJvckJvdW5kYXJ5ID0+IChfRXJyb3JCb3VuZGFyeSA9IGNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSwgX0Vycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pLCBfRXJyb3JCb3VuZGFyeSkpKCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdFN0YXRlKG9iaikge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIG51bDogYSA9PiBhID09PSBudWxsLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSB8fCBpcy5ib28oYSkpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzT2JqID0gaXMub2JqKGEpO1xuICAgIGlmIChpc09iaiAmJiBvYmplY3RzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNBcnIgPSBpcy5hcnIoYSk7XG4gICAgaWYgKGlzQXJyICYmIGFycmF5cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIC8vIEFycmF5IG9yIE9iamVjdCwgc2hhbGxvdyBjb21wYXJlIGZpcnN0IHRvIHNlZSBpZiBpdCdzIGEgbWF0Y2hcbiAgICBpZiAoKGlzQXJyIHx8IGlzT2JqKSAmJiBhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBMYXN0IHJlc29ydCwgZ28gdGhyb3VnaCBrZXlzXG4gICAgbGV0IGk7XG4gICAgLy8gQ2hlY2sgaWYgYSBoYXMgYWxsIHRoZSBrZXlzIG9mIGJcbiAgICBmb3IgKGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHZhbHVlcyBiZXR3ZWVuIGtleXMgbWF0Y2hcbiAgICBpZiAoaXNPYmogJiYgYXJyYXlzID09PSAnc2hhbGxvdycgJiYgb2JqZWN0cyA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmICghaXMuZXF1KGFbaV0sIGJbaV0sIHtcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBvYmplY3RzOiAncmVmZXJlbmNlJ1xuICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBpIGlzIHVuZGVmaW5lZFxuICAgIGlmIChpcy51bmQoaSkpIHtcbiAgICAgIC8vIElmIGJvdGggYXJyYXlzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNBcnIgJiYgYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gSWYgYm90aCBvYmplY3RzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNPYmogJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBPdGhlcndpc2UgbWF0Y2ggdGhlbSBieSB2YWx1ZVxuICAgICAgaWYgKGEgIT09IGIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNEXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9LFxuICAgIG1lc2hlczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgICAgaWYgKG9iai5pc01lc2ggJiYgIWRhdGEubWVzaGVzW29iai5uYW1lXSkgZGF0YS5tZXNoZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuLy8gRGlzcG9zZXMgYW4gb2JqZWN0IGFuZCBhbGwgaXRzIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGRpc3Bvc2Uob2JqKSB7XG4gIGlmIChvYmoudHlwZSAhPT0gJ1NjZW5lJykgb2JqLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBjb25zdCBwcm9wID0gb2JqW3BdO1xuICAgIGlmICgocHJvcCA9PSBudWxsID8gdm9pZCAwIDogcHJvcC50eXBlKSAhPT0gJ1NjZW5lJykgcHJvcCA9PSBudWxsID8gdm9pZCAwIDogcHJvcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwcm9wLmRpc3Bvc2UoKTtcbiAgfVxufVxuY29uc3QgUkVBQ1RfSU5URVJOQUxfUFJPUFMgPSBbJ2NoaWxkcmVuJywgJ2tleScsICdyZWYnXTtcblxuLy8gR2V0cyBvbmx5IGluc3RhbmNlIHByb3BzIGZyb20gcmVjb25jaWxlciBmaWJlcnNcbmZ1bmN0aW9uIGdldEluc3RhbmNlUHJvcHMocXVldWUpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcXVldWUpIHtcbiAgICBpZiAoIVJFQUNUX0lOVEVSTkFMX1BST1BTLmluY2x1ZGVzKGtleSkpIHByb3BzW2tleV0gPSBxdWV1ZVtrZXldO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUodGFyZ2V0LCByb290LCB0eXBlLCBwcm9wcykge1xuICBjb25zdCBvYmplY3QgPSB0YXJnZXQ7XG5cbiAgLy8gQ3JlYXRlIGluc3RhbmNlIGRlc2NyaXB0b3JcbiAgbGV0IGluc3RhbmNlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuX19yM2Y7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgIHJvb3QsXG4gICAgICB0eXBlLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgcHJvcHM6IGdldEluc3RhbmNlUHJvcHMocHJvcHMpLFxuICAgICAgb2JqZWN0LFxuICAgICAgZXZlbnRDb3VudDogMCxcbiAgICAgIGhhbmRsZXJzOiB7fSxcbiAgICAgIGlzSGlkZGVuOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKG9iamVjdCkgb2JqZWN0Ll9fcjNmID0gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IHJvb3Rba2V5XTtcbiAgaWYgKCFrZXkuaW5jbHVkZXMoJy0nKSkgcmV0dXJuIHtcbiAgICByb290LFxuICAgIGtleSxcbiAgICB0YXJnZXRcbiAgfTtcblxuICAvLyBSZXNvbHZlIHBpZXJjZWQgdGFyZ2V0XG4gIHRhcmdldCA9IHJvb3Q7XG4gIGZvciAoY29uc3QgcGFydCBvZiBrZXkuc3BsaXQoJy0nKSkge1xuICAgIHZhciBfdGFyZ2V0O1xuICAgIGtleSA9IHBhcnQ7XG4gICAgcm9vdCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSAoX3RhcmdldCA9IHRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRba2V5XTtcbiAgfVxuXG4gIC8vIFRPRE86IGNoYW5nZSBrZXkgdG8gJ2Zvby1iYXInIGlmIHRhcmdldCBpcyB1bmRlZmluZWQ/XG5cbiAgcmV0dXJuIHtcbiAgICByb290LFxuICAgIGtleSxcbiAgICB0YXJnZXRcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCkge1xuICBpZiAoaXMuc3RyKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICAvLyBJZiBhdHRhY2hpbmcgaW50byBhbiBhcnJheSAoZm9vLTApLCBjcmVhdGUgb25lXG4gICAgaWYgKElOREVYX1JFR0VYLnRlc3QoY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBjaGlsZC5wcm9wcy5hdHRhY2gucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb290LFxuICAgICAgICBrZXlcbiAgICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGluZGV4KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyb290W2tleV0pKSByb290W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGNoaWxkLnByb3BzLmF0dGFjaCk7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPSByb290W2tleV07XG4gICAgcm9vdFtrZXldID0gY2hpbGQub2JqZWN0O1xuICB9IGVsc2UgaWYgKGlzLmZ1bihjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPSBjaGlsZC5wcm9wcy5hdHRhY2gocGFyZW50Lm9iamVjdCwgY2hpbGQub2JqZWN0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKGlzLnN0cihjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGNoaWxkLnByb3BzLmF0dGFjaCk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSByb290W2tleV07XG4gICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBlbHNlIHJvb3Rba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5wcmV2aW91c0F0dGFjaChwYXJlbnQub2JqZWN0LCBjaGlsZC5vYmplY3QpO1xuICB9XG4gIGRlbGV0ZSBjaGlsZC5wcmV2aW91c0F0dGFjaDtcbn1cbmNvbnN0IFJFU0VSVkVEX1BST1BTID0gWy4uLlJFQUNUX0lOVEVSTkFMX1BST1BTLFxuLy8gSW5zdGFuY2UgcHJvcHNcbidhcmdzJywgJ2Rpc3Bvc2UnLCAnYXR0YWNoJywgJ29iamVjdCcsICdvblVwZGF0ZScsXG4vLyBCZWhhdmlvciBmbGFnc1xuJ2Rpc3Bvc2UnXTtcbmNvbnN0IE1FTU9JWkVEX1BST1RPVFlQRVMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZW1vaXplZFByb3RvdHlwZShyb290KSB7XG4gIGxldCBjdG9yID0gTUVNT0laRURfUFJPVE9UWVBFUy5nZXQocm9vdC5jb25zdHJ1Y3Rvcik7XG4gIHRyeSB7XG4gICAgaWYgKCFjdG9yKSB7XG4gICAgICBjdG9yID0gbmV3IHJvb3QuY29uc3RydWN0b3IoKTtcbiAgICAgIE1FTU9JWkVEX1BST1RPVFlQRVMuc2V0KHJvb3QuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIC4uLlxuICB9XG4gIHJldHVybiBjdG9yO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwgbmV3UHJvcHMpIHtcbiAgY29uc3QgY2hhbmdlZFByb3BzID0ge307XG5cbiAgLy8gU29ydCB0aHJvdWdoIHByb3BzXG4gIGZvciAoY29uc3QgcHJvcCBpbiBuZXdQcm9wcykge1xuICAgIC8vIFNraXAgcmVzZXJ2ZWQga2V5c1xuICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmNsdWRlcyhwcm9wKSkgY29udGludWU7XG4gICAgLy8gU2tpcCBpZiBwcm9wcyBtYXRjaFxuICAgIGlmIChpcy5lcXUobmV3UHJvcHNbcHJvcF0sIGluc3RhbmNlLnByb3BzW3Byb3BdKSkgY29udGludWU7XG5cbiAgICAvLyBQcm9wcyBjaGFuZ2VkLCBhZGQgdGhlbVxuICAgIGNoYW5nZWRQcm9wc1twcm9wXSA9IG5ld1Byb3BzW3Byb3BdO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3Qgb3RoZXIgaW4gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvdGhlci5zdGFydHNXaXRoKGAke3Byb3B9LWApKSBjaGFuZ2VkUHJvcHNbb3RoZXJdID0gbmV3UHJvcHNbb3RoZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHJlbW92ZWQgcHJvcHMgZm9yIEhNUlxuICBmb3IgKGNvbnN0IHByb3AgaW4gaW5zdGFuY2UucHJvcHMpIHtcbiAgICBpZiAoUkVTRVJWRURfUFJPUFMuaW5jbHVkZXMocHJvcCkgfHwgbmV3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShpbnN0YW5jZS5vYmplY3QsIHByb3ApO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChyb290LmNvbnN0cnVjdG9yICYmIHJvb3QuY29uc3RydWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgY29uc3QgY3RvciA9IGdldE1lbW9pemVkUHJvdG90eXBlKHJvb3QpO1xuICAgICAgaWYgKCFpcy51bmQoY3RvcikpIGNoYW5nZWRQcm9wc1trZXldID0gY3RvcltrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGNvbnN0cnVjdG9yLCBqdXN0IHNldCBpdCB0byAwXG4gICAgICBjaGFuZ2VkUHJvcHNba2V5XSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2VkUHJvcHM7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNzA0MlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIyNzQ4XG5jb25zdCBjb2xvck1hcHMgPSBbJ21hcCcsICdlbWlzc2l2ZU1hcCcsICdzaGVlbkNvbG9yTWFwJywgJ3NwZWN1bGFyQ29sb3JNYXAnLCAnZW52TWFwJ107XG5jb25zdCBFVkVOVF9SRUdFWCA9IC9eb24oUG9pbnRlcnxDbGlja3xEb3VibGVDbGlja3xDb250ZXh0TWVudXxXaGVlbCkvO1xuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzKG9iamVjdCwgcHJvcHMpIHtcbiAgdmFyIF9pbnN0YW5jZSRvYmplY3Q7XG4gIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0Ll9fcjNmO1xuICBjb25zdCByb290U3RhdGUgPSBpbnN0YW5jZSAmJiBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5ldmVudENvdW50O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twcm9wXTtcblxuICAgIC8vIERvbid0IG11dGF0ZSByZXNlcnZlZCBrZXlzXG4gICAgaWYgKFJFU0VSVkVEX1BST1BTLmluY2x1ZGVzKHByb3ApKSBjb250aW51ZTtcblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cywgaW5jbHVkaW5nIHJlbW92aW5nIHRoZW0gaWYgdW5kZWZpbmVkXG4gICAgaWYgKGluc3RhbmNlICYmIEVWRU5UX1JFR0VYLnRlc3QocHJvcCkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIGluc3RhbmNlLmhhbmRsZXJzW3Byb3BdID0gdmFsdWU7ZWxzZSBkZWxldGUgaW5zdGFuY2UuaGFuZGxlcnNbcHJvcF07XG4gICAgICBpbnN0YW5jZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElnbm9yZSBzZXR0aW5nIHVuZGVmaW5lZCBwcm9wc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBsZXQge1xuICAgICAgcm9vdCxcbiAgICAgIGtleSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSByZXNvbHZlKG9iamVjdCwgcHJvcCk7XG5cbiAgICAvLyBMYXllcnMgbXVzdCBiZSB3cml0dGVuIHRvIHRoZSBtYXNrIHByb3BlcnR5XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykge1xuICAgICAgdGFyZ2V0Lm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgIH1cbiAgICAvLyBTZXQgY29sb3JzIGlmIHZhbGlkIGNvbG9yIHJlcHJlc2VudGF0aW9uIGZvciBhdXRvbWF0aWMgY29udmVyc2lvbiAoY29weSlcbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciAmJiBpc0NvbG9yUmVwcmVzZW50YXRpb24odmFsdWUpKSB7XG4gICAgICB0YXJnZXQuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLy8gQ29weSBpZiBwcm9wZXJ0aWVzIG1hdGNoIHNpZ25hdHVyZXMgYW5kIGltcGxlbWVudCBtYXRoIGludGVyZmFjZSAobGlrZWx5IHJlYWQtb25seSlcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHRhcmdldC5jb3B5ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGFyZ2V0LmNvcHkodmFsdWUpO1xuICAgIH1cbiAgICAvLyBTZXQgYXJyYXkgdHlwZXNcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmZyb21BcnJheSA9PT0gJ2Z1bmN0aW9uJykgdGFyZ2V0LmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXQuc2V0KC4uLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gU2V0IGxpdGVyYWwgdHlwZXNcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gQWxsb3cgc2V0dGluZyBhcnJheSBzY2FsYXJzXG4gICAgICBpZiAodHlwZW9mIHRhcmdldC5zZXRTY2FsYXIgPT09ICdmdW5jdGlvbicpIHRhcmdldC5zZXRTY2FsYXIodmFsdWUpO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IHNpbmdsZSB2YWx1ZVxuICAgICAgZWxzZSB0YXJnZXQuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgZWxzZSB7XG4gICAgICB2YXIgX3Jvb3Qka2V5O1xuICAgICAgcm9vdFtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmUgcGFyYW1ldGVycyBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTg1N1xuICAgICAgaWYgKHJvb3RTdGF0ZSAmJiAhcm9vdFN0YXRlLmxpbmVhciAmJiBjb2xvck1hcHMuaW5jbHVkZXMoa2V5KSAmJiAoX3Jvb3Qka2V5ID0gcm9vdFtrZXldKSAhPSBudWxsICYmIF9yb290JGtleS5pc1RleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgcm9vdFtrZXldLmZvcm1hdCA9PT0gVEhSRUUuUkdCQUZvcm1hdCAmJiByb290W2tleV0udHlwZSA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzIGNhbm5vdCBiZSBzZXQgZnJvbSB0aGUgcmVuZGVyZXIgKGUuZy4gc1JHQiBzb3VyY2UgdGV4dHVyZXMgcmVuZGVyZWQgdG8gUDMpXG4gICAgICAgIHJvb3Rba2V5XS5jb2xvclNwYWNlID0gVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UucGFyZW50ICYmIHJvb3RTdGF0ZSAhPSBudWxsICYmIHJvb3RTdGF0ZS5pbnRlcm5hbCAmJiAoX2luc3RhbmNlJG9iamVjdCA9IGluc3RhbmNlLm9iamVjdCkgIT0gbnVsbCAmJiBfaW5zdGFuY2Ukb2JqZWN0LmlzT2JqZWN0M0QgJiYgcHJldkhhbmRsZXJzICE9PSBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gaW5zdGFuY2Uub2JqZWN0O1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCA+IC0xKSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAvLyBBZGQgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyIG9ubHkgd2hlbiBpdCBoYXMgaGFuZGxlcnNcbiAgICBpZiAoaW5zdGFuY2UuZXZlbnRDb3VudCAmJiBvYmplY3QucmF5Y2FzdCAhPT0gbnVsbCkge1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGluc3RhbmNlLm9iamVjdC5pc0J1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5wcm9wcy5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlLm9iamVjdC5pc01hdGVyaWFsKSBpbnN0YW5jZS5wcm9wcy5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICB9XG5cbiAgLy8gSW5zdGFuY2Ugd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZVxuICBpZiAoaW5zdGFuY2UpIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRyb290O1xuICBpZiAoIWluc3RhbmNlLnBhcmVudCkgcmV0dXJuO1xuICBpbnN0YW5jZS5wcm9wcy5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UucHJvcHMub25VcGRhdGUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgY29uc3Qgc3RhdGUgPSAoX2luc3RhbmNlJHJvb3QgPSBpbnN0YW5jZS5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRyb290LmdldFN0YXRlKCk7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPT09IDApIHN0YXRlLmludmFsaWRhdGUoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgaWYgKGNhbWVyYS5tYW51YWwpIHJldHVybjtcbiAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICBjYW1lcmEubGVmdCA9IHNpemUud2lkdGggLyAtMjtcbiAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgIGNhbWVyYS5ib3R0b20gPSBzaXplLmhlaWdodCAvIC0yO1xuICB9IGVsc2Uge1xuICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gIH1cbiAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbn1cbmNvbnN0IGlzT2JqZWN0M0QgPSBvYmplY3QgPT4gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuaXNPYmplY3QzRDtcblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vKipcclxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgYW55dGhpbmcgaGFzIGJlZW4gZm91bmQsIGZvcndhcmQgaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHtcbiAgICAgICAgc3RvcHBlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGhpdCBvZiBpbnRlcnNlY3Rpb25zKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KTtcblxuICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIG5vdCBtYW5hZ2VkIGJ5IFIzRiwgaXQgbWlnaHQgYmUgcGFyZW50ZWQgdG8gYW4gZWxlbWVudCB3aGljaCBpcy5cbiAgICAgICAgLy8gVHJhdmVyc2UgdXB3YXJkcyB1bnRpbCB3ZSBmaW5kIGEgbWFuYWdlZCBwYXJlbnQgYW5kIHVzZSBpdHMgc3RhdGUgaW5zdGVhZC5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIGhpdC5vYmplY3QudHJhdmVyc2VBbmNlc3RvcnMob2JqID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAgICAgICBpZiAocGFyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBwYXJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICAgIGNvbnN0IGhhc1BvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uOiBoaXQsXG4gICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpLnNldChoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgICAgLy8gY29udGFpbmluZyB0aGUgaGl0T2JqZWN0LCBhbmQgdGhlIGhpdC4gaGl0T2JqZWN0IGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlcywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgbmF0aXZlIGV2ZW50IHByb3BzXG4gICAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIGFzIGV2ZW50Lm5hdGl2ZUV2ZW50LmZuKClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByYXljYXN0RXZlbnQgPSB7XG4gICAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzU5NlxuICAgICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgICAgLy8gV2Ugb25seSBhdXRob3JpemUgc3RvcFByb3BhZ2F0aW9uLi4uXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAgICFjYXB0dXJlc0ZvclBvaW50ZXIgfHxcbiAgICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByYXljYXN0RXZlbnQuc3RvcHBlZCA9IGxvY2FsU3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuaG92ZXJlZC5zaXplICYmIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZmluZChpID0+IGkuZXZlbnRPYmplY3QgPT09IGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoWy4uLmhpZ2hlciwgaGl0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICAgIGNhbGxiYWNrKHJheWNhc3RFdmVudCk7XG4gICAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbFBvaW50ZXIoaW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBob3ZlcmVkT2JqIG9mIGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpIHtcbiAgICAgIC8vIFdoZW4gbm8gb2JqZWN0cyB3ZXJlIGhpdCBvciB0aGUgdGhlIGhvdmVyZWQgb2JqZWN0IHdhc24ndCBmb3VuZCB1bmRlcm5lYXRoIHRoZSBjdXJzb3JcbiAgICAgIC8vIHdlIGNhbGwgb25Qb2ludGVyT3V0IGFuZCBkZWxldGUgdGhlIG9iamVjdCBmcm9tIHRoZSBob3ZlcmVkLWVsZW1lbnRzIG1hcFxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmxlbmd0aCB8fCAhaW50ZXJzZWN0aW9ucy5maW5kKGhpdCA9PiBoaXQub2JqZWN0ID09PSBob3ZlcmVkT2JqLm9iamVjdCAmJiBoaXQuaW5kZXggPT09IGhvdmVyZWRPYmouaW5kZXggJiYgaGl0Lmluc3RhbmNlSWQgPT09IGhvdmVyZWRPYmouaW5zdGFuY2VJZCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBob3ZlcmVkT2JqLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZS5oYW5kbGVycztcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvKlxyXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxyXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcclxuICAgICAgICAgIEJ1dCB3b3VsZG4ndCBpdCBiZSBiZXR0ZXIgdG8ganVzdCByZXBsYWNlIGNhcHR1cmVkTWFwIHdpdGggYSBzaW5nbGUgZW50cnk/XHJcbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XHJcbiAgICAgICAgICBcclxuICAgICAgICBjb25zdCBwb2ludGVySWQgPSAoZGF0YSBhcyBUaHJlZUV2ZW50PFBvaW50ZXJFdmVudD4pLnBvaW50ZXJJZCAgICAgICAgXHJcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxyXG4gICAgICAgICAgaWYgKGNhcHR1cmVkTWVzaFNldCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RvcmUgPSBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldC5pc1ZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICB4cjogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHRvcCA9IDAsIGxlZnQgPSAwKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgIGludGVyYWN0aW9uOiBbXSxcbiAgICAgICAgaG92ZXJlZDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgIGluaXRpYWxDbGljazogWzAsIDBdLFxuICAgICAgICBpbml0aWFsSGl0czogW10sXG4gICAgICAgIGNhcHR1cmVkTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICAvLyBVcGRhdGVzXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIHN1YnNjcmliZTogKHJlZiwgcHJpb3JpdHksIHN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAvLyBJZiB0aGlzIHN1YnNjcmlwdGlvbiB3YXMgZ2l2ZW4gYSBwcmlvcml0eSwgaXQgdGFrZXMgcmVuZGVyaW5nIGludG8gaXRzIG93biBoYW5kc1xuICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiB3ZSBzd2l0Y2ggb2ZmIGF1dG9tYXRpYyByZW5kZXJpbmcgYW5kIGluY3JlYXNlIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlIHRoZXJlIGNhbiBiZSBubyBpbnRlcm5hbCByZW5kZXJpbmcgYXQgYWxsXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgKyAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdG9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIHN1YnNjcmliZXIgYW5kIHNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsXG4gICAgICAgICAgLy8gaGlnaGVzdCBwcmlvcml0eSByZW5kZXJzIGxhc3QgKG9uIHRvcCBvZiB0aGUgb3RoZXIgZnJhbWVzKVxuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwgJiYgaW50ZXJuYWwuc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgbWFudWFsIGZsYWcgaWYgdGhpcyBzdWJzY3JpcHRpb24gaGFkIGEgcHJpb3JpdHlcbiAgICAgICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSAtIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLmZpbHRlcihzID0+IHMucmVmICE9PSByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByb290U3RhdGU7XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuICBsZXQgb2xkU2l6ZSA9IHN0YXRlLnNpemU7XG4gIGxldCBvbGREcHIgPSBzdGF0ZS52aWV3cG9ydC5kcHI7XG4gIGxldCBvbGRDYW1lcmEgPSBzdGF0ZS5jYW1lcmE7XG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIHNpemUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGdsLFxuICAgICAgc2V0XG4gICAgfSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gUmVzaXplIGNhbWVyYSBhbmQgcmVuZGVyZXIgb24gY2hhbmdlcyB0byBzaXplIGFuZCBwaXhlbHJhdGlvXG4gICAgaWYgKHNpemUud2lkdGggIT09IG9sZFNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IG9sZFNpemUuaGVpZ2h0IHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBpZiAodmlld3BvcnQuZHByID4gMCkgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RvcmU7XG59O1xuXG4vKipcclxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgSW5zdGFuY2V9LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcclxuICpcclxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cclxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoaW5zdGFuY2UsICgpID0+IHJlZi5jdXJyZW50Ll9fcjNmLCBbcmVmXSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIFIzRiBDYW52YXMnIFp1c3RhbmQgc3RvcmUuIFVzZWZ1bCBmb3IgW3RyYW5zaWVudCB1cGRhdGVzXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQjdHJhbnNpZW50LXVwZGF0ZXMtZm9yLW9mdGVuLW9jY3VycmluZy1zdGF0ZS1jaGFuZ2VzKS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlc3RvcmVcclxuICovXG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmNvbnN0IG1lbW9pemVkTG9hZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpc0NvbnN0cnVjdG9yJDEgPSB2YWx1ZSA9PiB7XG4gIHZhciBfdmFsdWUkcHJvdG90eXBlO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogKF92YWx1ZSRwcm90b3R5cGUgPSB2YWx1ZS5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfdmFsdWUkcHJvdG90eXBlLmNvbnN0cnVjdG9yKSA9PT0gdmFsdWU7XG59O1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICBsZXQgbG9hZGVyO1xuXG4gICAgLy8gQ29uc3RydWN0IGFuZCBjYWNoZSBsb2FkZXIgaWYgY29uc3RydWN0b3Igd2FzIHBhc3NlZFxuICAgIGlmIChpc0NvbnN0cnVjdG9yJDEoUHJvdG8pKSB7XG4gICAgICBsb2FkZXIgPSBtZW1vaXplZExvYWRlcnMuZ2V0KFByb3RvKTtcbiAgICAgIGlmICghbG9hZGVyKSB7XG4gICAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgICBtZW1vaXplZExvYWRlcnMuc2V0KFByb3RvLCBsb2FkZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXIgPSBQcm90bztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBsb2FkZXIgZXh0ZW5zaW9uc1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG5cbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0M0QoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5zY2VuZSkpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKTtcbiAgfTtcbn1cblxuLyoqXHJcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cclxuICpcclxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXHJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKGxvYWRlciwgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbbG9hZGVyLCAuLi5rZXlzXSwge1xuICAgIGVxdWFsOiBpcy5lcXVcbiAgfSk7XG4gIC8vIFJldHVybiB0aGUgb2JqZWN0KHMpXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtsb2FkZXIsIC4uLmtleXNdKTtcbn07XG5cbi8qKlxyXG4gKiBSZW1vdmVzIGEgbG9hZGVkIGFzc2V0IGZyb20gY2FjaGUuXHJcbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW2xvYWRlciwgLi4ua2V5c10pO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUmVjb25jaWxlcihjb25maWcpIHtcbiAgY29uc3QgcmVjb25jaWxlciA9IFJlY29uY2lsZXIoY29uZmlnKTtcbiAgcmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICAgIGJ1bmRsZVR5cGU6IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gMSA6IDAsXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gICAgdmVyc2lvbjogUmVhY3QudmVyc2lvblxuICB9KTtcbiAgcmV0dXJuIHJlY29uY2lsZXI7XG59XG5jb25zdCBOb0V2ZW50UHJpb3JpdHkgPSAwO1xuXG4vLyBUT0RPOiBoYW5kbGUgY29uc3RydWN0b3Igb3ZlcmxvYWRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjkzMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzA3OVxuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IFBSRUZJWF9SRUdFWCA9IC9edGhyZWUoPz1bQS1aXSkvO1xuY29uc3QgdG9QYXNjYWxDYXNlID0gdHlwZSA9PiBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG5sZXQgaSA9IDA7XG5jb25zdCBpc0NvbnN0cnVjdG9yID0gb2JqZWN0ID0+IHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBleHRlbmQob2JqZWN0cykge1xuICBpZiAoaXNDb25zdHJ1Y3RvcihvYmplY3RzKSkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGAke2krK31gO1xuICAgIGNhdGFsb2d1ZVtDb21wb25lbnRdID0gb2JqZWN0cztcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24oY2F0YWxvZ3VlLCBvYmplY3RzKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcykge1xuICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gIGNvbnN0IG5hbWUgPSB0b1Bhc2NhbENhc2UodHlwZSk7XG4gIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVtuYW1lXTtcblxuICAvLyBWYWxpZGF0ZSBlbGVtZW50IHRhcmdldFxuICBpZiAodHlwZSAhPT0gJ3ByaW1pdGl2ZScgJiYgIXRhcmdldCkgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcblxuICAvLyBWYWxpZGF0ZSBwcmltaXRpdmVzXG4gIGlmICh0eXBlID09PSAncHJpbWl0aXZlJyAmJiAhcHJvcHMub2JqZWN0KSB0aHJvdyBuZXcgRXJyb3IoYFIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIWApO1xuXG4gIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgaWYgKHByb3BzLmFyZ3MgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwcm9wcy5hcmdzKSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IFRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290KSB7XG4gIHZhciBfcHJvcHMkb2JqZWN0O1xuICAvLyBSZW1vdmUgdGhyZWUqIHByZWZpeCBmcm9tIGVsZW1lbnRzIGlmIG5hdGl2ZSBlbGVtZW50IG5vdCBwcmVzZW50XG4gIHR5cGUgPSB0b1Bhc2NhbENhc2UodHlwZSkgaW4gY2F0YWxvZ3VlID8gdHlwZSA6IHR5cGUucmVwbGFjZShQUkVGSVhfUkVHRVgsICcnKTtcbiAgdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG5cbiAgLy8gUmVnZW5lcmF0ZSB0aGUgUjNGIGluc3RhbmNlIGZvciBwcmltaXRpdmVzIHRvIHNpbXVsYXRlIGEgbmV3IG9iamVjdFxuICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgKF9wcm9wcyRvYmplY3QgPSBwcm9wcy5vYmplY3QpICE9IG51bGwgJiYgX3Byb3BzJG9iamVjdC5fX3IzZikgZGVsZXRlIHByb3BzLm9iamVjdC5fX3IzZjtcbiAgcmV0dXJuIHByZXBhcmUocHJvcHMub2JqZWN0LCByb290LCB0eXBlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKCFpbnN0YW5jZS5pc0hpZGRlbikge1xuICAgIHZhciBfaW5zdGFuY2UkcGFyZW50O1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2ggJiYgKF9pbnN0YW5jZSRwYXJlbnQgPSBpbnN0YW5jZS5wYXJlbnQpICE9IG51bGwgJiYgX2luc3RhbmNlJHBhcmVudC5vYmplY3QpIHtcbiAgICAgIGRldGFjaChpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgaW5zdGFuY2Uub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5zdGFuY2UuaXNIaWRkZW4gPSB0cnVlO1xuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5pc0hpZGRlbikge1xuICAgIHZhciBfaW5zdGFuY2UkcGFyZW50MjtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoICYmIChfaW5zdGFuY2UkcGFyZW50MiA9IGluc3RhbmNlLnBhcmVudCkgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcGFyZW50Mi5vYmplY3QpIHtcbiAgICAgIGF0dGFjaChpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSAmJiBpbnN0YW5jZS5wcm9wcy52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgaW5zdGFuY2Uub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBpbnN0YW5jZS5pc0hpZGRlbiA9IGZhbHNlO1xuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYW5kIGF0dGFjaCBhcmUgb25seSBoYW5kbGVkIG9uY2Ugd2hlbiB0cmVlcyBhcmUgY29tcGxldGVcbmZ1bmN0aW9uIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgLy8gQmFpbCBpZiB0cmVlIGlzbid0IG1vdW50ZWQgb3IgcGFyZW50IGlzIG5vdCBhIGNvbnRhaW5lci5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRyZWUgaXMgZmluYWxpemVkIGFuZCBSZWFjdCB3b24ndCBkaXNjYXJkIHJlc3VsdHMgdG8gU3VzcGVuc2VcbiAgY29uc3Qgc3RhdGUgPSBjaGlsZC5yb290LmdldFN0YXRlKCk7XG4gIGlmICghcGFyZW50LnBhcmVudCAmJiBwYXJlbnQub2JqZWN0ICE9PSBzdGF0ZS5zY2VuZSkgcmV0dXJuO1xuXG4gIC8vIENyZWF0ZSAmIGxpbmsgb2JqZWN0IG9uIGZpcnN0IHJ1blxuICBpZiAoIWNoaWxkLm9iamVjdCkge1xuICAgIHZhciBfY2hpbGQkcHJvcHMkb2JqZWN0LCBfY2hpbGQkcHJvcHMkYXJncztcbiAgICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW3RvUGFzY2FsQ2FzZShjaGlsZC50eXBlKV07XG5cbiAgICAvLyBDcmVhdGUgb2JqZWN0XG4gICAgY2hpbGQub2JqZWN0ID0gKF9jaGlsZCRwcm9wcyRvYmplY3QgPSBjaGlsZC5wcm9wcy5vYmplY3QpICE9IG51bGwgPyBfY2hpbGQkcHJvcHMkb2JqZWN0IDogbmV3IHRhcmdldCguLi4oKF9jaGlsZCRwcm9wcyRhcmdzID0gY2hpbGQucHJvcHMuYXJncykgIT0gbnVsbCA/IF9jaGlsZCRwcm9wcyRhcmdzIDogW10pKTtcbiAgICBjaGlsZC5vYmplY3QuX19yM2YgPSBjaGlsZDtcbiAgfVxuXG4gIC8vIFNldCBpbml0aWFsIHByb3BzXG4gIGFwcGx5UHJvcHMoY2hpbGQub2JqZWN0LCBjaGlsZC5wcm9wcyk7XG5cbiAgLy8gQXBwZW5kIGluc3RhbmNlXG4gIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICBhdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICBjb25zdCBjaGlsZEluZGV4ID0gcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZUNoaWxkID09IG51bGwgPyB2b2lkIDAgOiBiZWZvcmVDaGlsZC5vYmplY3QpO1xuICAgIGlmIChiZWZvcmVDaGlsZCAmJiBjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhlIHBhcmVudCdzIGNoaWxkcmVuIGFycmF5LCBtb3ZlIGl0IHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCBpbnNlcnQgaXQgYXQgdGhlIHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHBhcmVudC5vYmplY3QuY2hpbGRyZW4uaW5kZXhPZihjaGlsZC5vYmplY3QpO1xuICAgICAgaWYgKGV4aXN0aW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGV4aXN0aW5nSW5kZXgsIDEpO1xuICAgICAgICBjb25zdCBhZGp1c3RlZEluZGV4ID0gZXhpc3RpbmdJbmRleCA8IGNoaWxkSW5kZXggPyBjaGlsZEluZGV4IC0gMSA6IGNoaWxkSW5kZXg7XG4gICAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGFkanVzdGVkSW5kZXgsIDAsIGNoaWxkLm9iamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5vYmplY3QucGFyZW50ID0gcGFyZW50Lm9iamVjdDtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGQub2JqZWN0KTtcbiAgICAgICAgY2hpbGQub2JqZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5vYmplY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2NoaWxkYWRkZWQnLFxuICAgICAgICAgIGNoaWxkOiBjaGlsZC5vYmplY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5vYmplY3QuYWRkKGNoaWxkLm9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGluayBzdWJ0cmVlXG4gIGZvciAoY29uc3QgY2hpbGRJbnN0YW5jZSBvZiBjaGlsZC5jaGlsZHJlbikgaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhjaGlsZCwgY2hpbGRJbnN0YW5jZSk7XG5cbiAgLy8gVHJlZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lXG4gIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghY2hpbGQpIHJldHVybjtcblxuICAvLyBMaW5rIGluc3RhbmNlc1xuICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7XG4gIHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAvLyBBdHRhY2ggdHJlZSBvbmNlIGNvbXBsZXRlXG4gIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgaWYgKCFjaGlsZCB8fCAhYmVmb3JlQ2hpbGQpIHJldHVybjtcblxuICAvLyBMaW5rIGluc3RhbmNlc1xuICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gIGlmIChjaGlsZEluZGV4ICE9PSAtMSkgcGFyZW50LmNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZCk7ZWxzZSBwYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgLy8gQXR0YWNoIHRyZWUgb25jZSBjb21wbGV0ZVxuICBoYW5kbGVDb250YWluZXJFZmZlY3RzKHBhcmVudCwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VPbklkbGUob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBoYW5kbGVEaXNwb3NlID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBuby1vcFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbiBhIHRlc3RpbmcgZW52aXJvbm1lbnQsIGNsZWFudXAgaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcpIGhhbmRsZURpc3Bvc2UoKTtcbiAgICAvLyBPdGhlcndpc2UsIHVzaW5nIGEgcmVhbCBHUFUgc28gc2NoZWR1bGUgY2xlYW51cCB0byBwcmV2ZW50IHN0YWxsc1xuICAgIGVsc2UgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGhhbmRsZURpc3Bvc2UpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnQsIGNoaWxkLCBkaXNwb3NlKSB7XG4gIGlmICghY2hpbGQpIHJldHVybjtcblxuICAvLyBVbmxpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gIGlmIChjaGlsZEluZGV4ICE9PSAtMSkgcGFyZW50LmNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAxKTtcblxuICAvLyBFYWdlcmx5IHRlYXIgZG93biB0cmVlXG4gIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICBkZXRhY2gocGFyZW50LCBjaGlsZCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICBwYXJlbnQub2JqZWN0LnJlbW92ZShjaGlsZC5vYmplY3QpO1xuICAgIHJlbW92ZUludGVyYWN0aXZpdHkoZmluZEluaXRpYWxSb290KGNoaWxkKSwgY2hpbGQub2JqZWN0KTtcbiAgfVxuXG4gIC8vIEFsbG93IG9iamVjdHMgdG8gYmFpbCBvdXQgb2YgdW5tb3VudCBkaXNwb3NhbCB3aXRoIGRpc3Bvc2U9e251bGx9XG4gIGNvbnN0IHNob3VsZERpc3Bvc2UgPSBjaGlsZC5wcm9wcy5kaXNwb3NlICE9PSBudWxsICYmIGRpc3Bvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IHJlbW92ZSBpbnN0YW5jZSBjaGlsZHJlblxuICBmb3IgKGxldCBpID0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gY2hpbGQuY2hpbGRyZW5baV07XG4gICAgcmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUsIHNob3VsZERpc3Bvc2UpO1xuICB9XG4gIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgLy8gVW5saW5rIGluc3RhbmNlIG9iamVjdFxuICBkZWxldGUgY2hpbGQub2JqZWN0Ll9fcjNmO1xuXG4gIC8vIERpc3Bvc2Ugb2JqZWN0IHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXQuXG4gIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gIC8vIEluIG9yZGVyIGZvciBhbiBvYmplY3QgdG8gYmUgYWJsZSB0byBkaXNwb3NlIGl0XG4gIC8vICAgLSBoYXMgYSBkaXNwb3NlIG1ldGhvZFxuICAvLyAgIC0gY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgLy8gICAtIGNhbm5vdCBiZSBhIFRIUkVFLlNjZW5lLCBiZWNhdXNlIHRocmVlIGhhcyBicm9rZW4gaXRzIG93biBBUElcbiAgaWYgKHNob3VsZERpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ3ByaW1pdGl2ZScgJiYgY2hpbGQub2JqZWN0LnR5cGUgIT09ICdTY2VuZScpIHtcbiAgICBkaXNwb3NlT25JZGxlKGNoaWxkLm9iamVjdCk7XG4gIH1cblxuICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWUgZm9yIHRvcC1sZXZlbCBpbnN0YW5jZVxuICBpZiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkKSBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xufVxuZnVuY3Rpb24gc2V0RmliZXJSZWYoZmliZXIsIHB1YmxpY0luc3RhbmNlKSB7XG4gIGZvciAoY29uc3QgX2ZpYmVyIG9mIFtmaWJlciwgZmliZXIuYWx0ZXJuYXRlXSkge1xuICAgIGlmIChfZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgX2ZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfZmliZXIucmVmQ2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogX2ZpYmVyLnJlZkNsZWFudXAoKTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IF9maWJlci5yZWYocHVibGljSW5zdGFuY2UpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIF9maWJlci5yZWZDbGVhbnVwID0gY2xlYW51cDtcbiAgICAgIH0gZWxzZSBpZiAoX2ZpYmVyLnJlZikge1xuICAgICAgICBfZmliZXIucmVmLmN1cnJlbnQgPSBwdWJsaWNJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHJlY29uc3RydWN0ZWQgPSBbXTtcbmZ1bmN0aW9uIHN3YXBJbnN0YW5jZXMoKSB7XG4gIC8vIERldGFjaCBpbnN0YW5jZVxuICBmb3IgKGNvbnN0IFtpbnN0YW5jZV0gb2YgcmVjb25zdHJ1Y3RlZCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5yZW1vdmUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgICAgICAgIGRldGFjaChpbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoY2hpbGQub2JqZWN0KSAmJiBpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5vYmplY3QucmVtb3ZlKGNoaWxkLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb2xkIGluc3RhbmNlIGlzIGhpZGRlbiwgd2UgbmVlZCB0byB1bmhpZGUgaXQuXG4gICAgLy8gUmVhY3QgYXNzdW1lcyBpdCBjYW4gZGlzY2FyZCBpbnN0YW5jZXMgc2luY2UgdGhleSdyZSBwdXJlIGZvciBET00uXG4gICAgLy8gVGhpcyBpc24ndCB0cnVlIGZvciB1cyBzaW5jZSBvdXIgbGlmZXRpbWVzIGFyZSBpbXB1cmUgYW5kIGxvbmdsaXZpbmcuXG4gICAgLy8gU28sIHdlIG1hbnVhbGx5IGNoZWNrIGlmIGFuIGluc3RhbmNlIHdhcyBoaWRkZW4gYW5kIHVuaGlkZSBpdC5cbiAgICBpZiAoaW5zdGFuY2UuaXNIaWRkZW4pIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlKTtcblxuICAgIC8vIERpc3Bvc2Ugb2Ygb2xkIG9iamVjdCBpZiBhYmxlXG4gICAgaWYgKGluc3RhbmNlLm9iamVjdC5fX3IzZikgZGVsZXRlIGluc3RhbmNlLm9iamVjdC5fX3IzZjtcbiAgICBpZiAoaW5zdGFuY2UudHlwZSAhPT0gJ3ByaW1pdGl2ZScpIGRpc3Bvc2VPbklkbGUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBpbnN0YW5jZVxuICBmb3IgKGNvbnN0IFtpbnN0YW5jZSwgcHJvcHMsIGZpYmVyXSBvZiByZWNvbnN0cnVjdGVkKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBjb25zdCBwYXJlbnQgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRvYmplYywgX2luc3RhbmNlJHByb3BzJGFyZ3M7XG4gICAgICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbdG9QYXNjYWxDYXNlKGluc3RhbmNlLnR5cGUpXTtcblxuICAgICAgLy8gQ3JlYXRlIG9iamVjdFxuICAgICAgaW5zdGFuY2Uub2JqZWN0ID0gKF9pbnN0YW5jZSRwcm9wcyRvYmplYyA9IGluc3RhbmNlLnByb3BzLm9iamVjdCkgIT0gbnVsbCA/IF9pbnN0YW5jZSRwcm9wcyRvYmplYyA6IG5ldyB0YXJnZXQoLi4uKChfaW5zdGFuY2UkcHJvcHMkYXJncyA9IGluc3RhbmNlLnByb3BzLmFyZ3MpICE9IG51bGwgPyBfaW5zdGFuY2UkcHJvcHMkYXJncyA6IFtdKSk7XG4gICAgICBpbnN0YW5jZS5vYmplY3QuX19yM2YgPSBpbnN0YW5jZTtcbiAgICAgIHNldEZpYmVyUmVmKGZpYmVyLCBpbnN0YW5jZS5vYmplY3QpO1xuXG4gICAgICAvLyBTZXQgaW5pdGlhbCBwcm9wc1xuICAgICAgYXBwbHlQcm9wcyhpbnN0YW5jZS5vYmplY3QsIGluc3RhbmNlLnByb3BzKTtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgICAgICBwYXJlbnQub2JqZWN0LmFkZChpbnN0YW5jZS5vYmplY3QpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgICAgYXR0YWNoKGluc3RhbmNlLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgICAgIGluc3RhbmNlLm9iamVjdC5hZGQoY2hpbGQub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWVcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIHJlY29uc3RydWN0ZWQubGVuZ3RoID0gMDtcbn1cblxuLy8gRG9uJ3QgaGFuZGxlIHRleHQgaW5zdGFuY2VzLCBtYWtlIGl0IG5vLW9wXG5jb25zdCBoYW5kbGVUZXh0SW5zdGFuY2UgPSAoKSA9PiB7fTtcbmNvbnN0IE5PX0NPTlRFWFQgPSB7fTtcbmxldCBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBOb0V2ZW50UHJpb3JpdHk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckZsYWdzLmpzXG5jb25zdCBOb0ZsYWdzID0gMDtcbmNvbnN0IFVwZGF0ZSA9IDQ7XG5jb25zdCByZWNvbmNpbGVyID0gLyogQF9fUFVSRV9fICovY3JlYXRlUmVjb25jaWxlcih7XG4gIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgd2FybnNJZk5vdEFjdGluZzogZmFsc2UsXG4gIHN1cHBvcnRzTXV0YXRpb246IHRydWUsXG4gIHN1cHBvcnRzUGVyc2lzdGVuY2U6IGZhbHNlLFxuICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQsXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIGluc2VydEJlZm9yZSxcbiAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIGFwcGVuZENoaWxkKHNjZW5lLCBjaGlsZCk7XG4gIH0sXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIHJlbW92ZUNoaWxkKHNjZW5lLCBjaGlsZCk7XG4gIH0sXG4gIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCB8fCAhc2NlbmUpIHJldHVybjtcbiAgICBpbnNlcnRCZWZvcmUoc2NlbmUsIGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH0sXG4gIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gTk9fQ09OVEVYVCxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogKCkgPT4gTk9fQ09OVEVYVCxcbiAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9uZXdQcm9wcyRhcmdzLCBfb2xkUHJvcHMkYXJncywgX25ld1Byb3BzJGFyZ3MyO1xuICAgIHZhbGlkYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMpO1xuICAgIGxldCByZWNvbnN0cnVjdCA9IGZhbHNlO1xuXG4gICAgLy8gUmVjb25zdHJ1Y3QgcHJpbWl0aXZlcyBpZiBvYmplY3QgcHJvcCBjaGFuZ2VzXG4gICAgaWYgKGluc3RhbmNlLnR5cGUgPT09ICdwcmltaXRpdmUnICYmIG9sZFByb3BzLm9iamVjdCAhPT0gbmV3UHJvcHMub2JqZWN0KSByZWNvbnN0cnVjdCA9IHRydWU7XG4gICAgLy8gUmVjb25zdHJ1Y3QgaW5zdGFuY2UgaWYgYXJncyB3ZXJlIGFkZGVkIG9yIHJlbW92ZWRcbiAgICBlbHNlIGlmICgoKF9uZXdQcm9wcyRhcmdzID0gbmV3UHJvcHMuYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXdQcm9wcyRhcmdzLmxlbmd0aCkgIT09ICgoX29sZFByb3BzJGFyZ3MgPSBvbGRQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX29sZFByb3BzJGFyZ3MubGVuZ3RoKSkgcmVjb25zdHJ1Y3QgPSB0cnVlO1xuICAgIC8vIFJlY29uc3RydWN0IGluc3RhbmNlIGlmIGFyZ3Mgd2VyZSBjaGFuZ2VkXG4gICAgZWxzZSBpZiAoKF9uZXdQcm9wcyRhcmdzMiA9IG5ld1Byb3BzLmFyZ3MpICE9IG51bGwgJiYgX25ld1Byb3BzJGFyZ3MyLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9vbGRQcm9wcyRhcmdzMjtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gKChfb2xkUHJvcHMkYXJnczIgPSBvbGRQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX29sZFByb3BzJGFyZ3MyW2luZGV4XSk7XG4gICAgfSkpIHJlY29uc3RydWN0ID0gdHJ1ZTtcblxuICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICBpZiAocmVjb25zdHJ1Y3QpIHtcbiAgICAgIHJlY29uc3RydWN0ZWQucHVzaChbaW5zdGFuY2UsIHtcbiAgICAgICAgLi4ubmV3UHJvcHNcbiAgICAgIH0sIGZpYmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgY29uc3QgY2hhbmdlZFByb3BzID0gZGlmZlByb3BzKGluc3RhbmNlLCBuZXdQcm9wcyk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZS5wcm9wcywgY2hhbmdlZFByb3BzKTtcbiAgICAgICAgYXBwbHlQcm9wcyhpbnN0YW5jZS5vYmplY3QsIGNoYW5nZWRQcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggcmVjb25zdHJ1Y3RlZCBzaWJsaW5ncyB3aGVuIHdlIGhpdCB0aGUgbGFzdCB1cGRhdGVkIGNoaWxkIGluIGEgc2VxdWVuY2VcbiAgICBjb25zdCBpc1RhaWxTaWJsaW5nID0gZmliZXIuc2libGluZyA9PT0gbnVsbCB8fCAoZmliZXIuZmxhZ3MgJiBVcGRhdGUpID09PSBOb0ZsYWdzO1xuICAgIGlmIChpc1RhaWxTaWJsaW5nKSBzd2FwSW5zdGFuY2VzKCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiAoKSA9PiBmYWxzZSxcbiAgY29tbWl0TW91bnQoKSB7fSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5vYmplY3QsXG4gIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNvbnRhaW5lciwgJycsIHt9KSxcbiAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICBoaWRlSW5zdGFuY2UsXG4gIHVuaGlkZUluc3RhbmNlLFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgc2NoZWR1bGVUaW1lb3V0OiB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIGNhbmNlbFRpbWVvdXQ6IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIG5vVGltZW91dDogLTEsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6ICgpID0+IG51bGwsXG4gIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cigpIHt9LFxuICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cigpIHt9LFxuICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoKSB7fSxcbiAgcHJlcGFyZVNjb3BlVXBkYXRlKCkge30sXG4gIGdldEluc3RhbmNlRnJvbVNjb3BlOiAoKSA9PiBudWxsLFxuICBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uOiAoKSA9PiBmYWxzZSxcbiAgdHJhY2tTY2hlZHVsZXJFdmVudDogKCkgPT4ge30sXG4gIHJlc29sdmVFdmVudFR5cGU6ICgpID0+IG51bGwsXG4gIHJlc29sdmVFdmVudFRpbWVTdGFtcDogKCkgPT4gLTEuMSxcbiAgcmVxdWVzdFBvc3RQYWludENhbGxiYWNrKCkge30sXG4gIG1heVN1c3BlbmRDb21taXQ6ICgpID0+IGZhbHNlLFxuICBwcmVsb2FkSW5zdGFuY2U6ICgpID0+IHRydWUsXG4gIC8vIHRydWUgaW5kaWNhdGVzIGFscmVhZHkgbG9hZGVkXG4gIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpIHt9LFxuICBzdXNwZW5kSW5zdGFuY2UoKSB7fSxcbiAgd2FpdEZvckNvbW1pdFRvQmVSZWFkeTogKCkgPT4gbnVsbCxcbiAgTm90UGVuZGluZ1RyYW5zaXRpb246IG51bGwsXG4gIC8vIFRoZSByZWNvbmNpbGVyIHR5cGVzIHVzZSB0aGUgaW50ZXJuYWwgUmVhY3RDb250ZXh0IHdpdGggYWxsIHRoZSBoaWRkZW4gcHJvcGVydGllc1xuICAvLyBzbyB3ZSBoYXZlIHRvIGNhc3QgZnJvbSB0aGUgcHVibGljIFJlYWN0LkNvbnRleHQgdHlwZVxuICBIb3N0VHJhbnNpdGlvbkNvbnRleHQ6IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCksXG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICAgIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IG5ld1ByaW9yaXR5O1xuICB9LFxuICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgfSxcbiAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkge1xuICAgIHZhciBfd2luZG93JGV2ZW50O1xuICAgIGlmIChjdXJyZW50VXBkYXRlUHJpb3JpdHkgIT09IE5vRXZlbnRQcmlvcml0eSkgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRldmVudCA9IHdpbmRvdy5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckZXZlbnQudHlwZSkpIHtcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgICAgY2FzZSAncG9pbnRlcmRvd24nOlxuICAgICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0Rm9ybUluc3RhbmNlKCkge31cbn0pO1xuXG5jb25zdCBfcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHNpemUpIHtcbiAgaWYgKCFzaXplICYmIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH07XG4gIH0gZWxzZSBpZiAoIXNpemUgJiYgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5zaXplXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KGNhbnZhcykge1xuICAvLyBDaGVjayBhZ2FpbnN0IG1pc3Rha2VuIHVzZSBvZiBjcmVhdGVSb290XG4gIGNvbnN0IHByZXZSb290ID0gX3Jvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsXG4gIC8vIGNvbnRhaW5lclxuICBDb25jdXJyZW50Um9vdCxcbiAgLy8gdGFnXG4gIG51bGwsXG4gIC8vIGh5ZHJhdGlvbiBjYWxsYmFja3NcbiAgZmFsc2UsXG4gIC8vIGlzU3RyaWN0TW9kZVxuICBudWxsLFxuICAvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlXG4gICcnLFxuICAvLyBpZGVudGlmaWVyUHJlZml4XG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uVW5jYXVnaHRFcnJvclxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvbkNhdWdodEVycm9yXG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uUmVjb3ZlcmFibGVFcnJvclxuICBudWxsIC8vIHRyYW5zaXRpb25DYWxsYmFja3NcbiAgKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIF9yb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZyA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCByZXNvbHZlO1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHJlc29sdmUgPSBfcmVzb2x2ZSk7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgYWxwaGE6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2xDb25maWcgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBnbENvbmZpZyhkZWZhdWx0UHJvcHMpIDogZ2xDb25maWc7XG4gICAgICAgIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkge1xuICAgICAgICAgIGdsID0gY3VzdG9tUmVuZGVyZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICAuLi5nbENvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgZ2xcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FtZXJhT3B0aW9ucy5pc0NhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB1c2VyLWRlZmluZWQgZnJ1c3R1bSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzE2MFxuICAgICAgICAgICAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgICAgICAgICAgIGlmICgnYXNwZWN0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdsZWZ0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdyaWdodCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnYm90dG9tJyBpbiBjYW1lcmFPcHRpb25zIHx8ICd0b3AnIGluIGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEubWFudWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zICE9IG51bGwgJiYgc2NlbmVPcHRpb25zLmlzU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgICBwcmVwYXJlKHNjZW5lLCBzdG9yZSwgJycsIHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIHByZXBhcmUoc2NlbmUsIHN0b3JlLCAnJywge30pO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O1xuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgZ2wub3V0cHV0Q29sb3JTcGFjZSA9IGxpbmVhciA/IFRIUkVFLkxpbmVhclNSR0JDb2xvclNwYWNlIDogVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGdsLnRvbmVNYXBwaW5nID0gZmxhdCA/IFRIUkVFLk5vVG9uZU1hcHBpbmcgOiBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCAmJiAhcGVuZGluZykgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHBlbmRpbmcudGhlbigoKSA9PiB7XG4gICAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovanN4KFByb3ZpZGVyLCB7XG4gICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICAgIH0pLCBmaWJlciwgbnVsbCwgKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmeSB0aGF0IGluaXQgaXMgY29tcGxldGVkLCB0aGUgc2NlbmUgZ3JhcGggZXhpc3RzLCBidXQgbm90aGluZyBoYXMgeWV0IHJlbmRlcmVkXG4gICAgaWYgKG9uQ3JlYXRlZCkgb25DcmVhdGVkKHN0YXRlKTtcbiAgICAvLyBDb25uZWN0IGV2ZW50cyB0byB0aGUgdGFyZ2V0cyBwYXJlbnQsIHRoaXMgaXMgZG9uZSB0byBlbnN1cmUgZXZlbnRzIGFyZSByZWdpc3RlcmVkIG9uXG4gICAgLy8gYSBzaGFyZWQgdGFyZ2V0LCBhbmQgbm90IG9uIHRoZSBjYW52YXMgaXRzZWxmXG4gICAgaWYgKCFzdG9yZS5nZXRTdGF0ZSgpLmV2ZW50cy5jb25uZWN0ZWQpIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChyb290RWxlbWVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSBfcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IGZpYmVyID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5maWJlcjtcbiAgaWYgKGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlKSBzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgPSBmYWxzZTtcbiAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCBmaWJlciwgbnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlJGdsLCBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMsIF9zdGF0ZSRnbDIsIF9zdGF0ZSRnbDM7XG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfc3RhdGUkZ2wkcmVuZGVyTGlzdHMgPSBfc3RhdGUkZ2wucmVuZGVyTGlzdHMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wyID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgaWYgKChfc3RhdGUkZ2wzID0gc3RhdGUuZ2wpICE9IG51bGwgJiYgX3N0YXRlJGdsMy54cikgc3RhdGUueHIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGlzcG9zZShzdGF0ZS5zY2VuZSk7XG4gICAgICAgICAgICBfcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUG9ydGFsLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcclxuICAgKiAgaWYgdGhpcyBpcyBvdXIgZW52aXJvbm1lbnQsIHRoZW4gd2UgYXJlIG5vdCBpbiByM2YncyByZW5kZXJlciBidXQgaW4gcmVhY3QtZG9tLCBpdCB3b3VsZCB0cmlnZ2VyXHJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxyXG4gICAqICA8Q2FudmFzPlxyXG4gICAqICAgIHtjcmVhdGVQb3J0YWwoLi4uKX0gKi9cbiAgY29uc3Qge1xuICAgIGV2ZW50cyxcbiAgICBzaXplLFxuICAgIC4uLnJlc3RcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBwcmV2aW91c1Jvb3QgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbcmF5Y2FzdGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSB1c2VNdXRhYmxlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlLmNhbWVyYSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5yb290U3RhdGUsXG4gICAgICAuLi5pbmplY3RTdGF0ZSxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5pbmplY3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gaW5qZWN0U3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH07XG4gIH0pO1xuICBjb25zdCB1c2VQb3J0YWxTdG9yZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG1pcnJvcmVkIHN0b3JlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcm9vdCB3aXRoIGEgZmV3IG92ZXJyaWRlcyAuLi5cbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBzZXQsXG4gICAgICBnZXRcbiAgICB9KSk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IG9uTXV0YXRlID0gcHJldiA9PiBzdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QuY3VycmVudChwcmV2LCBzdGF0ZSkpO1xuICAgIG9uTXV0YXRlKHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICBwcmV2aW91c1Jvb3Quc3Vic2NyaWJlKG9uTXV0YXRlKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbcHJldmlvdXNSb290LCBjb250YWluZXJdKTtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQHRzLWlnbm9yZSwgcmVjb25jaWxlciB0eXBlcyBhcmUgbm90IG1haW50YWluZWRcbiAgICBqc3goRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiByZWNvbmNpbGVyLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KSwgdXNlUG9ydGFsU3RvcmUsIG51bGwpXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXHJcbiAqIEZvcmNlIFJlYWN0IHRvIGZsdXNoIGFueSB1cGRhdGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc3luY2hyb25vdXNseSBhbmQgaW1tZWRpYXRlbHkuXHJcbiAqIEFsbCB0aGUgc2FtZSBjYXZlYXRzIGRvY3VtZW50ZWQgZm9yIHJlYWN0LWRvbSdzIGBmbHVzaFN5bmNgIGFwcGx5IGhlcmUgKHNlZSBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QtZG9tL2ZsdXNoU3luYykuXHJcbiAqIE5ldmVydGhlbGVzcywgc29tZXRpbWVzIG9uZSBuZWVkcyB0byByZW5kZXIgc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUgdG8ga2VlcCBET00gYW5kIDNEIGNoYW5nZXMgaW4gbG9jay1zdGVwIHdpdGhvdXRcclxuICogaGF2aW5nIHRvIHJldmVydCB0byBhIG5vbi1SZWFjdCBzb2x1dGlvbi4gTm90ZTogdGhpcyB3aWxsIG9ubHkgZmx1c2ggdXBkYXRlcyB3aXRoaW4gdGhlIGBDYW52YXNgIHJvb3QuXHJcbiAqL1xuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIC8vIEB0cy1pZ25vcmUgLSByZWNvbmNpbGVyIHR5cGVzIGFyZSBub3QgbWFpbnRhaW5lZFxuICByZXR1cm4gcmVjb25jaWxlci5mbHVzaFN5bmNGcm9tUmVjb25jaWxlcihmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5jb25zdCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRBZnRlckVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkVGFpbFxyXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcblxuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuXG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG5cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcblxuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxubGV0IHJ1bm5pbmcgPSBmYWxzZTtcbmxldCB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbmxldCByZXBlYXQ7XG5sZXQgZnJhbWU7XG5sZXQgc3RhdGU7XG5mdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgcnVubmluZyA9IHRydWU7XG4gIHJlcGVhdCA9IDA7XG5cbiAgLy8gUnVuIGVmZmVjdHNcbiAgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuXG4gIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgdXNlRnJhbWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgZm9yIChjb25zdCByb290IG9mIF9yb290cy52YWx1ZXMoKSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICByZXBlYXQgKz0gdXBkYXRlKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjaW52YWxpZGF0ZVxyXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gIGlmICghc3RhdGUpIHJldHVybiBfcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpLCBmcmFtZXMpKTtcbiAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgaWYgKGZyYW1lcyA+IDEpIHtcbiAgICAvLyBsZWdhY3kgc3VwcG9ydCBmb3IgcGVvcGxlIHVzaW5nIGZyYW1lcyBwYXJhbWV0ZXJzXG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodXNlRnJhbWVJblByb2dyZXNzKSB7XG4gICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiBhIHVzZUZyYW1lLCBpdCBtZWFucyB0aGUgdXNlciB3YW50cyBhbiBhZGRpdGlvbmFsIGZyYW1lXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoZSB1c2VyIG5lZWQgYSBuZXcgZnJhbWUsIG5vIG5lZWQgdG8gaW5jcmVtZW50IGZ1cnRoZXIgdGhhbiAxXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSByZW5kZXItbG9vcCBpc24ndCBhY3RpdmUsIHN0YXJ0IGl0XG4gIGlmICghcnVubmluZykge1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgfVxufVxuXG4vKipcclxuICogQWR2YW5jZXMgdGhlIGZyYW1lbG9vcCBhbmQgcnVucyByZW5kZXIgZWZmZWN0cywgdXNlZnVsIGZvciB3aGVuIG1hbnVhbGx5IHJlbmRlcmluZyB2aWEgYGZyYW1lbG9vcD1cIm5ldmVyXCJgLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWR2YW5jZVxyXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gIGlmICghc3RhdGUpIGZvciAoY29uc3Qgcm9vdCBvZiBfcm9vdHMudmFsdWVzKCkpIHVwZGF0ZSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpO1xuICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG59XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgaWYgKGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICBpZiAoZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZVN0b3JlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZVRocmVlIGFzIEMsIHVzZUZyYW1lIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlR3JhcGggYXMgRiwgdXNlTG9hZGVyIGFzIEcsIF9yb290cyBhcyBfLCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgYSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBiLCBjcmVhdGVSb290IGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNyZWF0ZVBvaW50ZXJFdmVudHMgYXMgZiwgY3JlYXRlRXZlbnRzIGFzIGcsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBoLCBpc1JlZiBhcyBpLCBhZGRFZmZlY3QgYXMgaiwgYWRkQWZ0ZXJFZmZlY3QgYXMgaywgYWRkVGFpbCBhcyBsLCBpbnZhbGlkYXRlIGFzIG0sIGFkdmFuY2UgYXMgbiwgY3JlYXRlUG9ydGFsIGFzIG8sIGZsdXNoU3luYyBhcyBwLCBjb250ZXh0IGFzIHEsIHJlY29uY2lsZXIgYXMgciwgYXBwbHlQcm9wcyBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZUJyaWRnZSBhcyB1LCBnZXRSb290U3RhdGUgYXMgdiwgZGlzcG9zZSBhcyB3LCBhY3QgYXMgeCwgYnVpbGRHcmFwaCBhcyB5LCB1c2VJbnN0YW5jZUhhbmRsZSBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   act: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   advance: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   events: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   extend: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)\n/* harmony export */ });\n/* harmony import */ var _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-e3cb66e2.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction CanvasImpl({\n  ref,\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events = _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.f,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n  const Bridge = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)();\n  const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, () => canvasRef.current);\n  const handlePointerMissed = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(onPointerMissed);\n  const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n  const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(canvas);\n      async function run() {\n        await root.current.configure({\n          gl,\n          scene,\n          events,\n          shadows,\n          linear,\n          flat,\n          legacy,\n          orthographic,\n          frameloop,\n          dpr,\n          performance,\n          raycaster,\n          camera,\n          size: containerRect,\n          // Pass mutable reference to onPointerMissed so it's free to update\n          onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n          onCreated: state => {\n            // Connect to event source\n            state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n            // Set up compute function\n            if (eventPrefix) {\n              state.setEvents({\n                compute: (event, state) => {\n                  const x = event[eventPrefix + 'X'];\n                  const y = event[eventPrefix + 'Y'];\n                  state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                  state.raycaster.setFromCamera(state.pointer, state.camera);\n                }\n              });\n            }\n            // Call onCreated callback\n            onCreated == null ? void 0 : onCreated(state);\n          }\n        });\n        root.current.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n            set: setError,\n            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n              fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                set: setBlock\n              }),\n              children: children != null ? children : null\n            })\n          })\n        }));\n      }\n      run();\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    },\n    ...props,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          display: 'block'\n        },\n        children: fallback\n      })\n    })\n  });\n}\n\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */\nfunction Canvas(props) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n      ...props\n    })\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9QO0FBQ2tSO0FBQ3ZlO0FBQ0E7QUFDWTtBQUNGO0FBQ0Q7QUFDSjtBQUNQO0FBQ047QUFDRztBQUNQOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMENBQWEsT0FBTywwREFBTSxDQUFDLGtDQUFLO0FBQ2xDLGlCQUFpQiwwREFBUztBQUMxQix3Q0FBd0MsNkRBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLHlDQUFZO0FBQ2hDLGlCQUFpQix5Q0FBWTtBQUM3QixFQUFFLHNEQUF5QjtBQUMzQiw4QkFBOEIsMERBQWtCO0FBQ2hELDRCQUE0QiwyQ0FBYztBQUMxQyw0QkFBNEIsMkNBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBWTtBQUMzQixFQUFFLDBEQUF5QjtBQUMzQjtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsMERBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQyxzREFBRztBQUM3QyxpQ0FBaUMsc0RBQUcsQ0FBQyxzREFBYTtBQUNsRDtBQUNBLG1DQUFtQyxzREFBRyxDQUFDLDJDQUFjO0FBQ3JELHFDQUFxQyxzREFBRyxDQUFDLHNEQUFLO0FBQzlDO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSw2QkFBNkIsMERBQXNCO0FBQ25ELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNEQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUcsQ0FBQyxtREFBYTtBQUN2QywyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVrQiIsInNvdXJjZXMiOlsiQzpcXGpzcHJvalxccmVhY3QtbGFydHpcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxmaWJlclxcZGlzdFxccmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGUgYXMgZXh0ZW5kLCB1IGFzIHVzZUJyaWRnZSwgYSBhcyB1c2VNdXRhYmxlQ2FsbGJhY2ssIGIgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgYyBhcyBjcmVhdGVSb290LCBpIGFzIGlzUmVmLCBFIGFzIEVycm9yQm91bmRhcnksIEIgYXMgQmxvY2ssIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgZiBhcyBjcmVhdGVQb2ludGVyRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMtZTNjYjY2ZTIuZXNtLmpzJztcbmV4cG9ydCB7IHQgYXMgUmVhY3RUaHJlZUZpYmVyLCBfIGFzIF9yb290cywgeCBhcyBhY3QsIGsgYXMgYWRkQWZ0ZXJFZmZlY3QsIGogYXMgYWRkRWZmZWN0LCBsIGFzIGFkZFRhaWwsIG4gYXMgYWR2YW5jZSwgcyBhcyBhcHBseVByb3BzLCB5IGFzIGJ1aWxkR3JhcGgsIHEgYXMgY29udGV4dCwgZyBhcyBjcmVhdGVFdmVudHMsIG8gYXMgY3JlYXRlUG9ydGFsLCBjIGFzIGNyZWF0ZVJvb3QsIHcgYXMgZGlzcG9zZSwgZiBhcyBldmVudHMsIGUgYXMgZXh0ZW5kLCBoIGFzIGZsdXNoR2xvYmFsRWZmZWN0cywgcCBhcyBmbHVzaFN5bmMsIHYgYXMgZ2V0Um9vdFN0YXRlLCBtIGFzIGludmFsaWRhdGUsIHIgYXMgcmVjb25jaWxlciwgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBEIGFzIHVzZUZyYW1lLCBGIGFzIHVzZUdyYXBoLCB6IGFzIHVzZUluc3RhbmNlSGFuZGxlLCBHIGFzIHVzZUxvYWRlciwgQSBhcyB1c2VTdG9yZSwgQyBhcyB1c2VUaHJlZSB9IGZyb20gJy4vZXZlbnRzLWUzY2I2NmUyLmVzbS5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgdXNlTWVhc3VyZSBmcm9tICdyZWFjdC11c2UtbWVhc3VyZSc7XG5pbXBvcnQgeyBGaWJlclByb3ZpZGVyIH0gZnJvbSAnaXRzLWZpbmUnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0ICdzdXNwZW5kLXJlYWN0JztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgJ3NjaGVkdWxlcic7XG5cbmZ1bmN0aW9uIENhbnZhc0ltcGwoe1xuICByZWYsXG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSkge1xuICAvLyBDcmVhdGUgYSBrbm93biBjYXRhbG9ndWUgb2YgVGhyZWVqcy1uYXRpdmUgZWxlbWVudHNcbiAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIGVudGlyZSBUSFJFRSBuYW1lc3BhY2UgYnkgZGVmYXVsdCwgdXNlcnMgY2FuIGV4dGVuZFxuICAvLyB0aGVpciBvd24gZWxlbWVudHMgYnkgdXNpbmcgdGhlIGNyZWF0ZVJvb3QgQVBJIGluc3RlYWRcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoVEhSRUUpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IHVzZUJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgYXdhaXQgcm9vdC5jdXJyZW50LmNvbmZpZ3VyZSh7XG4gICAgICAgICAgZ2wsXG4gICAgICAgICAgc2NlbmUsXG4gICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgIHNoYWRvd3MsXG4gICAgICAgICAgbGluZWFyLFxuICAgICAgICAgIGZsYXQsXG4gICAgICAgICAgbGVnYWN5LFxuICAgICAgICAgIG9ydGhvZ3JhcGhpYyxcbiAgICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgICAgZHByLFxuICAgICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgICAvLyBQYXNzIG11dGFibGUgcmVmZXJlbmNlIHRvIG9uUG9pbnRlck1pc3NlZCBzbyBpdCdzIGZyZWUgdG8gdXBkYXRlXG4gICAgICAgICAgb25Qb2ludGVyTWlzc2VkOiAoLi4uYXJncykgPT4gaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQoLi4uYXJncyksXG4gICAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIGV2ZW50IHNvdXJjZVxuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KGV2ZW50U291cmNlID8gaXNSZWYoZXZlbnRTb3VyY2UpID8gZXZlbnRTb3VyY2UuY3VycmVudCA6IGV2ZW50U291cmNlIDogZGl2UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmIChldmVudFByZWZpeCkge1xuICAgICAgICAgICAgICBzdGF0ZS5zZXRFdmVudHMoe1xuICAgICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBldmVudFtldmVudFByZWZpeCArICdYJ107XG4gICAgICAgICAgICAgICAgICBjb25zdCB5ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWSddO1xuICAgICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsbCBvbkNyZWF0ZWQgY2FsbGJhY2tcbiAgICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovanN4KEJyaWRnZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICAgIHNldDogc2V0RXJyb3IsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChSZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qL2pzeChCbG9jaywge1xuICAgICAgICAgICAgICAgIHNldDogc2V0QmxvY2tcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbiAhPSBudWxsID8gY2hpbGRyZW4gOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJ1bigpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IGRpdlJlZixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBwb2ludGVyRXZlbnRzLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImNhbnZhc1wiLCB7XG4gICAgICAgIHJlZjogY2FudmFzUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGZhbGxiYWNrXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufVxuXG4vKipcclxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvY2FudmFzXHJcbiAqL1xuZnVuY3Rpb24gQ2FudmFzKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZpYmVyUHJvdmlkZXIsIHtcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChDYW52YXNJbXBsLCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDYW52YXMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), requestHostCallback();\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n    }\n    function requestHostCallback() {\n      isMessageLoopRunning ||\n        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_continueExecution = function () {\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback());\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_getFirstCallbackNode = function () {\n      return peek(taskQueue);\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_pauseExecution = function () {};\n    exports.unstable_requestPaint = function () {};\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), requestHostCallback()));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSSxxQ0FBcUM7QUFDekMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUM7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkM6XFxqc3Byb2pcXHJlYWN0LWxhcnR6XFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXG5vZGVfbW9kdWxlc1xcc2NoZWR1bGVyXFxjanNcXHNjaGVkdWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICAgICAgaWYgKGlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExO1xuICAgICAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLFxuICAgICAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUYXNrKSBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgICAgICAoaXNQZXJmb3JtaW5nV29yayA9ICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBoYXNNb3JlV29ya1xuICAgICAgICAgICAgPyBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpXG4gICAgICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxLFxuICAgICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgICAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgICAgICAoaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlKSxcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHBhcmVudCksXG4gICAgICAgICAgICAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgICAgICBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgYTogZm9yIChcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDEsXG4gICAgICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICAgICAgcmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGVmdClcbiAgICAgICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCkpXG4gICAgICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSBsZWZ0SW5kZXgpKTtcbiAgICAgICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICAgICAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gdGltZXIuY2FsbGJhY2spIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgICAgICh0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZSksXG4gICAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZClcbiAgICAgICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbCA/ICExIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICAgIHRpbWVyUXVldWUgPSBbXSxcbiAgICAgIHRhc2tJZENvdW50ZXIgPSAxLFxuICAgICAgY3VycmVudFRhc2sgPSBudWxsLFxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICExLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsU2V0SW1tZWRpYXRlID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGwsXG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xLFxuICAgICAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gICAgICBzdGFydFRpbWUgPSAtMTtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gICAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIGV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IChmcmFtZUludGVydmFsID0gMCA8IGZwcyA/IE1hdGguZmxvb3IoMWUzIC8gZnBzKSA6IDUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuZGVsYXkpLFxuICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgICAgID8gY3VycmVudFRpbWUgKyBvcHRpb25zXG4gICAgICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgICAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gNWUzO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICAgICAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IG9wdGlvbnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgICAgIHB1c2godGltZXJRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgICAgICAoaXNIb3N0VGltZW91dFNjaGVkdWxlZFxuICAgICAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgb3B0aW9ucyAtIGN1cnJlbnRUaW1lKSkpXG4gICAgICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gICAgICByZXR1cm4gcHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHlLQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsiQzpcXGpzcHJvalxccmVhY3QtbGFydHpcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxmaWJlclxcbm9kZV9tb2R1bGVzXFxzY2hlZHVsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyCollider: () => (/* binding */ AnyCollider),\n/* harmony export */   BallCollider: () => (/* binding */ BallCollider),\n/* harmony export */   CapsuleCollider: () => (/* binding */ CapsuleCollider),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   ConeCollider: () => (/* binding */ ConeCollider),\n/* harmony export */   ConvexHullCollider: () => (/* binding */ ConvexHullCollider),\n/* harmony export */   CuboidCollider: () => (/* binding */ CuboidCollider),\n/* harmony export */   CylinderCollider: () => (/* binding */ CylinderCollider),\n/* harmony export */   HeightfieldCollider: () => (/* binding */ HeightfieldCollider),\n/* harmony export */   InstancedRigidBodies: () => (/* binding */ InstancedRigidBodies),\n/* harmony export */   MeshCollider: () => (/* binding */ MeshCollider),\n/* harmony export */   Physics: () => (/* binding */ Physics),\n/* harmony export */   RapierCollider: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   RapierRigidBody: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RoundConeCollider: () => (/* binding */ RoundConeCollider),\n/* harmony export */   RoundCuboidCollider: () => (/* binding */ RoundCuboidCollider),\n/* harmony export */   RoundCylinderCollider: () => (/* binding */ RoundCylinderCollider),\n/* harmony export */   TrimeshCollider: () => (/* binding */ TrimeshCollider),\n/* harmony export */   euler: () => (/* binding */ euler),\n/* harmony export */   interactionGroups: () => (/* binding */ interactionGroups),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   useAfterPhysicsStep: () => (/* binding */ useAfterPhysicsStep),\n/* harmony export */   useBeforePhysicsStep: () => (/* binding */ useBeforePhysicsStep),\n/* harmony export */   useFixedJoint: () => (/* binding */ useFixedJoint),\n/* harmony export */   useImpulseJoint: () => (/* binding */ useImpulseJoint),\n/* harmony export */   usePrismaticJoint: () => (/* binding */ usePrismaticJoint),\n/* harmony export */   useRapier: () => (/* binding */ useRapier),\n/* harmony export */   useRevoluteJoint: () => (/* binding */ useRevoluteJoint),\n/* harmony export */   useRopeJoint: () => (/* binding */ useRopeJoint),\n/* harmony export */   useSphericalJoint: () => (/* binding */ useSphericalJoint),\n/* harmony export */   useSpringJoint: () => (/* binding */ useSpringJoint),\n/* harmony export */   vec3: () => (/* binding */ vec3)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n\n\n\n\n\n\n\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nconst _vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst _matrix4 = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst _rotation = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nconst _scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v[0], v[1], v[2], v[3]);\n  } else {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Vector3 || v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(callback);\n  const raf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  const lastFrame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cb.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : (0,three_stdlib__WEBPACK_IMPORTED_MODULE_4__.mergeVertices)(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS | _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n    geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"group\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\"));\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = (0,suspend_react__WEBPACK_IMPORTED_MODULE_5__.suspend)(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  const getInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useRigidBodyContext = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const instanceWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, colliderNodes.map((node, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9kaXN0L3JlYWN0LXRocmVlLXJhcGllci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUN2QjtBQUNyRTtBQUNvRTtBQUNRO0FBQzVGO0FBQ0s7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUFVO0FBQ2xDLElBQUksd0NBQUs7QUFDVCxxQkFBcUIsMENBQU87QUFDNUIsSUFBSSwyQ0FBUTtBQUNaLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDZDQUFVO0FBQ2hDLG1CQUFtQiwwQ0FBTzs7QUFFMUI7QUFDQTtBQUNBLGFBQWEsMENBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSixlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSjtBQUNBLGVBQWUsOERBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFZO0FBQzNCLElBQUk7QUFDSixlQUFlLGlFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5ZSIsInNvdXJjZXMiOlsiQzpcXGpzcHJvalxccmVhY3QtbGFydHpcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxyYXBpZXJcXGRpc3RcXHJlYWN0LXRocmVlLXJhcGllci5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyBhcyBWZWN0b3IzJDEsIFF1YXRlcm5pb24gYXMgUXVhdGVybmlvbiQxLCBBY3RpdmVFdmVudHMsIENvbGxpZGVyRGVzYywgRXZlbnRRdWV1ZSwgUmlnaWRCb2R5RGVzYyB9IGZyb20gJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnO1xuZXhwb3J0IHsgQ29lZmZpY2llbnRDb21iaW5lUnVsZSwgQ29sbGlkZXIgYXMgUmFwaWVyQ29sbGlkZXIsIFJpZ2lkQm9keSBhcyBSYXBpZXJSaWdpZEJvZHkgfSBmcm9tICdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0JztcbmltcG9ydCB7IHVzZUZyYW1lLCB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QsIG1lbW8sIHVzZU1lbW8sIHVzZUNvbnRleHQsIHVzZVN0YXRlLCBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBFdWxlciwgVmVjdG9yMywgT2JqZWN0M0QsIE1hdHJpeDQsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIE1hdGhVdGlscywgRHluYW1pY0RyYXdVc2FnZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHN1c3BlbmQgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcbmltcG9ydCB7IG1lcmdlVmVydGljZXMgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmNvbnN0IF9xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbm5ldyBFdWxlcigpO1xuY29uc3QgX3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xubmV3IE9iamVjdDNEKCk7XG5jb25zdCBfbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3JvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9zY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IHZlY3RvckFycmF5VG9WZWN0b3IzID0gYXJyID0+IHtcbiAgY29uc3QgW3gsIHksIHpdID0gYXJyO1xuICByZXR1cm4gbmV3IFZlY3RvcjMoeCwgeSwgeik7XG59O1xuY29uc3QgcmFwaWVyUXVhdGVybmlvblRvUXVhdGVybmlvbiA9ICh7XG4gIHgsXG4gIHksXG4gIHosXG4gIHdcbn0pID0+IF9xdWF0ZXJuaW9uLnNldCh4LCB5LCB6LCB3KTtcbmNvbnN0IHZlY3RvcjNUb1JhcGllclZlY3RvciA9IHYgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyQxKHZbMF0sIHZbMV0sIHZbMl0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzJDEodiwgdiwgdik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGhyZWVWZWN0b3IzID0gdjtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMkMSh0aHJlZVZlY3RvcjMueCwgdGhyZWVWZWN0b3IzLnksIHRocmVlVmVjdG9yMy56KTtcbiAgfVxufTtcbmNvbnN0IHF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24gPSB2ID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24kMSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24kMSh2LngsIHYueSwgdi56LCB2LncpO1xuICB9XG59O1xuY29uc3QgcmlnaWRCb2R5VHlwZU1hcCA9IHtcbiAgZml4ZWQ6IDEsXG4gIGR5bmFtaWM6IDAsXG4gIGtpbmVtYXRpY1Bvc2l0aW9uOiAyLFxuICBraW5lbWF0aWNWZWxvY2l0eTogM1xufTtcbmNvbnN0IHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nID0gdHlwZSA9PiByaWdpZEJvZHlUeXBlTWFwW3R5cGVdO1xuY29uc3Qgc2NhbGVWZXJ0aWNlcyA9ICh2ZXJ0aWNlcywgc2NhbGUpID0+IHtcbiAgY29uc3Qgc2NhbGVkVmVydHMgPSBBcnJheS5mcm9tKHZlcnRpY2VzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICBzY2FsZWRWZXJ0c1tpICogM10gKj0gc2NhbGUueDtcbiAgICBzY2FsZWRWZXJ0c1tpICogMyArIDFdICo9IHNjYWxlLnk7XG4gICAgc2NhbGVkVmVydHNbaSAqIDMgKyAyXSAqPSBzY2FsZS56O1xuICB9XG4gIHJldHVybiBzY2FsZWRWZXJ0cztcbn07XG5jb25zdCB2ZWN0b3JUb1R1cGxlID0gdiA9PiB7XG4gIGlmICghdikgcmV0dXJuIFswXTtcbiAgaWYgKHYgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uKSB7XG4gICAgcmV0dXJuIFt2LngsIHYueSwgdi56LCB2LnddO1xuICB9XG4gIGlmICh2IGluc3RhbmNlb2YgVmVjdG9yMyB8fCB2IGluc3RhbmNlb2YgRXVsZXIpIHtcbiAgICByZXR1cm4gW3YueCwgdi55LCB2LnpdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgcmV0dXJuIFt2XTtcbn07XG5mdW5jdGlvbiB1c2VDb25zdChpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGlmIChyZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB7XG4gICAgICB2YWx1ZTogdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gaW5pdGlhbFZhbHVlKCkgOiBpbml0aWFsVmFsdWVcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWYuY3VycmVudC52YWx1ZTtcbn1cblxuY29uc3QgdXNlUmFmID0gY2FsbGJhY2sgPT4ge1xuICBjb25zdCBjYiA9IHVzZVJlZihjYWxsYmFjayk7XG4gIGNvbnN0IHJhZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgbGFzdEZyYW1lID0gdXNlUmVmKDApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNiLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSwgW2NhbGxiYWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZGVsdGEgPSBub3cgLSBsYXN0RnJhbWUuY3VycmVudDtcbiAgICAgIHJhZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgY2IuY3VycmVudChkZWx0YSAvIDEwMDApO1xuICAgICAgbGFzdEZyYW1lLmN1cnJlbnQgPSBub3c7XG4gICAgfTtcbiAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICB9LCBbXSk7XG59O1xuXG5jb25zdCBVc2VGcmFtZVN0ZXBwZXIgPSAoe1xuICBvblN0ZXAsXG4gIHVwZGF0ZVByaW9yaXR5XG59KSA9PiB7XG4gIHVzZUZyYW1lKChfLCBkdCkgPT4ge1xuICAgIG9uU3RlcChkdCk7XG4gIH0sIHVwZGF0ZVByaW9yaXR5KTtcbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgUmFmU3RlcHBlciA9ICh7XG4gIG9uU3RlcFxufSkgPT4ge1xuICB1c2VSYWYoZHQgPT4ge1xuICAgIG9uU3RlcChkdCk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBGcmFtZVN0ZXBwZXIgPSAoe1xuICBvblN0ZXAsXG4gIHR5cGUsXG4gIHVwZGF0ZVByaW9yaXR5XG59KSA9PiB7XG4gIHJldHVybiB0eXBlID09PSBcImluZGVwZW5kZW50XCIgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSYWZTdGVwcGVyLCB7XG4gICAgb25TdGVwOiBvblN0ZXBcbiAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChVc2VGcmFtZVN0ZXBwZXIsIHtcbiAgICBvblN0ZXA6IG9uU3RlcCxcbiAgICB1cGRhdGVQcmlvcml0eTogdXBkYXRlUHJpb3JpdHlcbiAgfSk7XG59O1xudmFyIEZyYW1lU3RlcHBlciQxID0gLyojX19QVVJFX18qL21lbW8oRnJhbWVTdGVwcGVyKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQyID0gW1wibWFzc1wiLCBcImxpbmVhckRhbXBpbmdcIiwgXCJhbmd1bGFyRGFtcGluZ1wiLCBcInR5cGVcIiwgXCJvbkNvbGxpc2lvbkVudGVyXCIsIFwib25Db2xsaXNpb25FeGl0XCIsIFwib25JbnRlcnNlY3Rpb25FbnRlclwiLCBcIm9uSW50ZXJzZWN0aW9uRXhpdFwiLCBcIm9uQ29udGFjdEZvcmNlXCIsIFwiY2hpbGRyZW5cIiwgXCJjYW5TbGVlcFwiLCBcImNjZFwiLCBcImdyYXZpdHlTY2FsZVwiLCBcInNvZnRDY2RQcmVkaWN0aW9uXCIsIFwicmVmXCJdO1xuY29uc3Qgc2NhbGVDb2xsaWRlckFyZ3MgPSAoc2hhcGUsIGFyZ3MsIHNjYWxlKSA9PiB7XG4gIGNvbnN0IG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG5cbiAgLy8gSGVpZ2h0ZmllbGQgdXNlcyBhIHZlY3RvclxuICBpZiAoc2hhcGUgPT09IFwiaGVpZ2h0ZmllbGRcIikge1xuICAgIGNvbnN0IHMgPSBuZXdBcmdzWzNdO1xuICAgIHMueCAqPSBzY2FsZS54O1xuICAgIHMueCAqPSBzY2FsZS55O1xuICAgIHMueCAqPSBzY2FsZS56O1xuICAgIHJldHVybiBuZXdBcmdzO1xuICB9XG5cbiAgLy8gVHJpbWVzaCBhbmQgY29udmV4IHNjYWxlIHRoZSB2ZXJ0aWNlc1xuICBpZiAoc2hhcGUgPT09IFwidHJpbWVzaFwiIHx8IHNoYXBlID09PSBcImNvbnZleEh1bGxcIikge1xuICAgIG5ld0FyZ3NbMF0gPSBzY2FsZVZlcnRpY2VzKG5ld0FyZ3NbMF0sIHNjYWxlKTtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfVxuXG4gIC8vIFByZXBmaWxsIHdpdGggc29tZSBleHRyYVxuICBjb25zdCBzY2FsZUFycmF5ID0gW3NjYWxlLngsIHNjYWxlLnksIHNjYWxlLnosIHNjYWxlLngsIHNjYWxlLnhdO1xuICByZXR1cm4gbmV3QXJncy5tYXAoKGFyZywgaW5kZXgpID0+IHNjYWxlQXJyYXlbaW5kZXhdICogYXJnKTtcbn07XG5jb25zdCBjcmVhdGVDb2xsaWRlckZyb21PcHRpb25zID0gKG9wdGlvbnMsIHdvcmxkLCBzY2FsZSwgZ2V0UmlnaWRCb2R5KSA9PiB7XG4gIGNvbnN0IHNjYWxlZEFyZ3MgPSBzY2FsZUNvbGxpZGVyQXJncyhvcHRpb25zLnNoYXBlLCBvcHRpb25zLmFyZ3MsIHNjYWxlKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkZXNjID0gQ29sbGlkZXJEZXNjW29wdGlvbnMuc2hhcGVdKC4uLnNjYWxlZEFyZ3MpO1xuICByZXR1cm4gd29ybGQuY3JlYXRlQ29sbGlkZXIoZGVzYywgZ2V0UmlnaWRCb2R5ID09PSBudWxsIHx8IGdldFJpZ2lkQm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0UmlnaWRCb2R5KCkpO1xufTtcbmNvbnN0IGltbXV0YWJsZUNvbGxpZGVyT3B0aW9ucyA9IFtcInNoYXBlXCIsIFwiYXJnc1wiXTtcbmNvbnN0IG1hc3NQcm9wZXJ0aWVzQ29uZmxpY3RFcnJvciA9IFwiUGxlYXNlIHBpY2sgT05MWSBPTkUgb2YgdGhlIGBkZW5zaXR5YCwgYG1hc3NgIGFuZCBgbWFzc1Byb3BlcnRpZXNgIG9wdGlvbnMuXCI7XG5jb25zdCBzZXRDb2xsaWRlck1hc3NPcHRpb25zID0gKGNvbGxpZGVyLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLmRlbnNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IpO1xuICAgIH1cbiAgICBjb2xsaWRlci5zZXREZW5zaXR5KG9wdGlvbnMuZGVuc2l0eSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IpO1xuICAgIH1cbiAgICBjb2xsaWRlci5zZXRNYXNzKG9wdGlvbnMubWFzcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb2xsaWRlci5zZXRNYXNzUHJvcGVydGllcyhvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLm1hc3MsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMuY2VudGVyT2ZNYXNzLCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLnByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLmFuZ3VsYXJJbmVydGlhTG9jYWxGcmFtZSk7XG4gIH1cbn07XG5jb25zdCBtdXRhYmxlQ29sbGlkZXJPcHRpb25zID0ge1xuICBzZW5zb3I6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRTZW5zb3IodmFsdWUpO1xuICB9LFxuICBjb2xsaXNpb25Hcm91cHM6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cHModmFsdWUpO1xuICB9LFxuICBzb2x2ZXJHcm91cHM6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRTb2x2ZXJHcm91cHModmFsdWUpO1xuICB9LFxuICBmcmljdGlvbjogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldEZyaWN0aW9uKHZhbHVlKTtcbiAgfSxcbiAgZnJpY3Rpb25Db21iaW5lUnVsZTogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldEZyaWN0aW9uQ29tYmluZVJ1bGUodmFsdWUpO1xuICB9LFxuICByZXN0aXR1dGlvbjogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldFJlc3RpdHV0aW9uKHZhbHVlKTtcbiAgfSxcbiAgcmVzdGl0dXRpb25Db21iaW5lUnVsZTogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldFJlc3RpdHV0aW9uQ29tYmluZVJ1bGUodmFsdWUpO1xuICB9LFxuICBhY3RpdmVDb2xsaXNpb25UeXBlczogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldEFjdGl2ZUNvbGxpc2lvblR5cGVzKHZhbHVlKTtcbiAgfSxcbiAgY29udGFjdFNraW46IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRDb250YWN0U2tpbih2YWx1ZSk7XG4gIH0sXG4gIC8vIFRvIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBhbGwgbXV0YWJsZSBvcHRpb25zIGFyZSBsaXN0ZWRcbiAgcXVhdGVybmlvbjogKCkgPT4ge30sXG4gIHBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgcm90YXRpb246ICgpID0+IHt9LFxuICBzY2FsZTogKCkgPT4ge31cbn07XG5jb25zdCBtdXRhYmxlQ29sbGlkZXJPcHRpb25LZXlzID0gT2JqZWN0LmtleXMobXV0YWJsZUNvbGxpZGVyT3B0aW9ucyk7XG5jb25zdCBzZXRDb2xsaWRlck9wdGlvbnMgPSAoY29sbGlkZXIsIG9wdGlvbnMsIHN0YXRlcykgPT4ge1xuICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY29sbGlkZXIuaGFuZGxlKTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgdmFyIF9zdGF0ZSR3b3JsZFBhcmVudDtcbiAgICAvLyBVcGRhdGUgY29sbGlkZXIgcG9zaXRpb24gYmFzZWQgb24gdGhlIG9iamVjdCdzIHBvc2l0aW9uXG4gICAgY29uc3QgcGFyZW50V29ybGRTY2FsZSA9IHN0YXRlLm9iamVjdC5wYXJlbnQuZ2V0V29ybGRTY2FsZShfdmVjdG9yMyk7XG4gICAgY29uc3QgcGFyZW50SW52ZXJ0ZWRXb3JsZE1hdHJpeCA9IChfc3RhdGUkd29ybGRQYXJlbnQgPSBzdGF0ZS53b3JsZFBhcmVudCkgPT09IG51bGwgfHwgX3N0YXRlJHdvcmxkUGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkd29ybGRQYXJlbnQubWF0cml4V29ybGQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIF9tYXRyaXg0LmNvcHkoc3RhdGUub2JqZWN0Lm1hdHJpeFdvcmxkKTtcbiAgICBpZiAocGFyZW50SW52ZXJ0ZWRXb3JsZE1hdHJpeCkge1xuICAgICAgX21hdHJpeDQucHJlbXVsdGlwbHkocGFyZW50SW52ZXJ0ZWRXb3JsZE1hdHJpeCk7XG4gICAgfVxuICAgIF9tYXRyaXg0LmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcbiAgICBpZiAoY29sbGlkZXIucGFyZW50KCkpIHtcbiAgICAgIGNvbGxpZGVyLnNldFRyYW5zbGF0aW9uV3J0UGFyZW50KHtcbiAgICAgICAgeDogX3Bvc2l0aW9uLnggKiBwYXJlbnRXb3JsZFNjYWxlLngsXG4gICAgICAgIHk6IF9wb3NpdGlvbi55ICogcGFyZW50V29ybGRTY2FsZS55LFxuICAgICAgICB6OiBfcG9zaXRpb24ueiAqIHBhcmVudFdvcmxkU2NhbGUuelxuICAgICAgfSk7XG4gICAgICBjb2xsaWRlci5zZXRSb3RhdGlvbldydFBhcmVudChfcm90YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xsaWRlci5zZXRUcmFuc2xhdGlvbih7XG4gICAgICAgIHg6IF9wb3NpdGlvbi54ICogcGFyZW50V29ybGRTY2FsZS54LFxuICAgICAgICB5OiBfcG9zaXRpb24ueSAqIHBhcmVudFdvcmxkU2NhbGUueSxcbiAgICAgICAgejogX3Bvc2l0aW9uLnogKiBwYXJlbnRXb3JsZFNjYWxlLnpcbiAgICAgIH0pO1xuICAgICAgY29sbGlkZXIuc2V0Um90YXRpb24oX3JvdGF0aW9uKTtcbiAgICB9XG4gICAgbXV0YWJsZUNvbGxpZGVyT3B0aW9uS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1trZXldO1xuICAgICAgICBtdXRhYmxlQ29sbGlkZXJPcHRpb25zW2tleV0oY29sbGlkZXIsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgT3B0aW9uIGRvZXMgbm90IHdhbnQgdG8gZml0IGludG8gdGhlIGZ1bmN0aW9uLCBidXQgaXQgd2lsbFxuICAgICAgICBvcHRpb24sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIG1hc3Mgc2VwYXJhdGVseSwgYmVjYXVzZSB0aGUgYXNzaWdubWVudHNcbiAgICAvLyBhcmUgZXhjbHVzaXZlLlxuICAgIHNldENvbGxpZGVyTWFzc09wdGlvbnMoY29sbGlkZXIsIG9wdGlvbnMpO1xuICB9XG59O1xuY29uc3QgdXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zID0gKGdldENvbGxpZGVyLCBwcm9wcywgc3RhdGVzKSA9PiB7XG4gIC8vIFRPRE86IEltcHJvdmUgdGhpcywgc3BsaXQgZWFjaCBwcm9wIGludG8gaXRzIG93biBlZmZlY3RcbiAgY29uc3QgbXV0YWJsZVByb3BzQXNGbGF0QXJyYXkgPSB1c2VNZW1vKCgpID0+IG11dGFibGVDb2xsaWRlck9wdGlvbktleXMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiB2ZWN0b3JUb1R1cGxlKHByb3BzW2tleV0pO1xuICB9KSwgW3Byb3BzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29sbGlkZXIgPSBnZXRDb2xsaWRlcigpO1xuICAgIHNldENvbGxpZGVyT3B0aW9ucyhjb2xsaWRlciwgcHJvcHMsIHN0YXRlcyk7XG4gIH0sIFsuLi5tdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSwgZ2V0Q29sbGlkZXJdKTtcbn07XG5jb25zdCBpc0NoaWxkT2ZNZXNoQ29sbGlkZXIgPSBjaGlsZCA9PiB7XG4gIGxldCBmbGFnID0gZmFsc2U7XG4gIGNoaWxkLnRyYXZlcnNlQW5jZXN0b3JzKGEgPT4ge1xuICAgIGlmIChhLnVzZXJEYXRhLnIzUmFwaWVyVHlwZSA9PT0gXCJNZXNoQ29sbGlkZXJcIikgZmxhZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gZmxhZztcbn07XG5jb25zdCBjcmVhdGVDb2xsaWRlclN0YXRlID0gKGNvbGxpZGVyLCBvYmplY3QsIHJpZ2lkQm9keU9iamVjdCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbGxpZGVyLFxuICAgIHdvcmxkUGFyZW50OiByaWdpZEJvZHlPYmplY3QgfHwgdW5kZWZpbmVkLFxuICAgIG9iamVjdFxuICB9O1xufTtcbmNvbnN0IGF1dG9Db2xsaWRlck1hcCA9IHtcbiAgY3Vib2lkOiBcImN1Ym9pZFwiLFxuICBiYWxsOiBcImJhbGxcIixcbiAgaHVsbDogXCJjb252ZXhIdWxsXCIsXG4gIHRyaW1lc2g6IFwidHJpbWVzaFwiXG59O1xuY29uc3QgY3JlYXRlQ29sbGlkZXJQcm9wc0Zyb21DaGlsZHJlbiA9ICh7XG4gIG9iamVjdCxcbiAgaWdub3JlTWVzaENvbGxpZGVyczogX2lnbm9yZU1lc2hDb2xsaWRlcnMgPSB0cnVlLFxuICBvcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IFtdO1xuICBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICBjb25zdCBpbnZlcnRlZFBhcmVudE1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG4gIGNvbnN0IGNvbGxpZGVyRnJvbUNoaWxkID0gY2hpbGQgPT4ge1xuICAgIGlmIChcImlzTWVzaFwiIGluIGNoaWxkKSB7XG4gICAgICBpZiAoX2lnbm9yZU1lc2hDb2xsaWRlcnMgJiYgaXNDaGlsZE9mTWVzaENvbGxpZGVyKGNoaWxkKSkgcmV0dXJuO1xuICAgICAgY29uc3Qgd29ybGRTY2FsZSA9IGNoaWxkLmdldFdvcmxkU2NhbGUoX3NjYWxlKTtcbiAgICAgIGNvbnN0IHNoYXBlID0gYXV0b0NvbGxpZGVyTWFwW29wdGlvbnMuY29sbGlkZXJzIHx8IFwiY3Vib2lkXCJdO1xuICAgICAgY2hpbGQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgICAgX21hdHJpeDQuY29weShjaGlsZC5tYXRyaXhXb3JsZCkucHJlbXVsdGlwbHkoaW52ZXJ0ZWRQYXJlbnRNYXRyaXhXb3JsZCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuICAgICAgY29uc3Qgcm90YXRpb25FdWxlciA9IG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKF9yb3RhdGlvbiwgXCJYWVpcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGdldENvbGxpZGVyQXJnc0Zyb21HZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucy5jb2xsaWRlcnMgfHwgXCJjdWJvaWRcIik7XG4gICAgICBjb25zdCBjb2xsaWRlclByb3BzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlcihvcHRpb25zKSksIHt9LCB7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgcm90YXRpb246IFtyb3RhdGlvbkV1bGVyLngsIHJvdGF0aW9uRXVsZXIueSwgcm90YXRpb25FdWxlci56XSxcbiAgICAgICAgcG9zaXRpb246IFtfcG9zaXRpb24ueCArIG9mZnNldC54ICogd29ybGRTY2FsZS54LCBfcG9zaXRpb24ueSArIG9mZnNldC55ICogd29ybGRTY2FsZS55LCBfcG9zaXRpb24ueiArIG9mZnNldC56ICogd29ybGRTY2FsZS56XSxcbiAgICAgICAgc2NhbGU6IFt3b3JsZFNjYWxlLngsIHdvcmxkU2NhbGUueSwgd29ybGRTY2FsZS56XVxuICAgICAgfSk7XG4gICAgICBjaGlsZENvbGxpZGVyUHJvcHMucHVzaChjb2xsaWRlclByb3BzKTtcbiAgICB9XG4gIH07XG4gIGlmIChvcHRpb25zLmluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBvYmplY3QudHJhdmVyc2UoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdC50cmF2ZXJzZVZpc2libGUoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9XG4gIHJldHVybiBjaGlsZENvbGxpZGVyUHJvcHM7XG59O1xuY29uc3QgZ2V0Q29sbGlkZXJBcmdzRnJvbUdlb21ldHJ5ID0gKGdlb21ldHJ5LCBjb2xsaWRlcnMpID0+IHtcbiAgc3dpdGNoIChjb2xsaWRlcnMpIHtcbiAgICBjYXNlIFwiY3Vib2lkXCI6XG4gICAgICB7XG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYm91bmRpbmdCb3hcbiAgICAgICAgfSA9IGdlb21ldHJ5O1xuICAgICAgICBjb25zdCBzaXplID0gYm91bmRpbmdCb3guZ2V0U2l6ZShuZXcgVmVjdG9yMygpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbc2l6ZS54IC8gMiwgc2l6ZS55IC8gMiwgc2l6ZS56IC8gMl0sXG4gICAgICAgICAgb2Zmc2V0OiBib3VuZGluZ0JveC5nZXRDZW50ZXIobmV3IFZlY3RvcjMoKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwiYmFsbFwiOlxuICAgICAge1xuICAgICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJvdW5kaW5nU3BoZXJlXG4gICAgICAgIH0gPSBnZW9tZXRyeTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtyYWRpdXNdLFxuICAgICAgICAgIG9mZnNldDogYm91bmRpbmdTcGhlcmUuY2VudGVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSBcInRyaW1lc2hcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jbG9uZWRHZW9tZXRyeSRpbmRleDtcbiAgICAgICAgY29uc3QgY2xvbmVkR2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmNsb25lKCkgOiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbY2xvbmVkR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSwgKF9jbG9uZWRHZW9tZXRyeSRpbmRleCA9IGNsb25lZEdlb21ldHJ5LmluZGV4KSA9PT0gbnVsbCB8fCBfY2xvbmVkR2VvbWV0cnkkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbG9uZWRHZW9tZXRyeSRpbmRleC5hcnJheV0sXG4gICAgICAgICAgb2Zmc2V0OiBuZXcgVmVjdG9yMygpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSBcImh1bGxcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZyA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczogW2cuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheV0sXG4gICAgICAgICAgb2Zmc2V0OiBuZXcgVmVjdG9yMygpXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhcmdzOiBbXSxcbiAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgfTtcbn07XG5jb25zdCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMgPSBwcm9wcyA9PiB7XG4gIHJldHVybiB7XG4gICAgY29sbGlzaW9uOiAhIShwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uQ29sbGlzaW9uRW50ZXIgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkNvbGxpc2lvbkV4aXQgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkludGVyc2VjdGlvbkVudGVyIHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25JbnRlcnNlY3Rpb25FeGl0KSxcbiAgICBjb250YWN0Rm9yY2U6ICEhKHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25Db250YWN0Rm9yY2UpXG4gIH07XG59O1xuY29uc3QgdXNlQ29sbGlkZXJFdmVudHMgPSAoZ2V0Q29sbGlkZXIsIHByb3BzLCBldmVudHMsXG4vKipcbiAqIFRoZSBSaWdpZEJvZHkgY2FuIHBhc3MgZG93biBhY3RpdmUgZXZlbnRzIHRvIHRoZSBjb2xsaWRlciB3aXRob3V0IGF0dGFjaGluZyB0aGUgZXZlbnQgbGlzdG5lcnNcbiAqL1xuYWN0aXZlRXZlbnRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgb25Db2xsaXNpb25FeGl0LFxuICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgIG9uQ29udGFjdEZvcmNlXG4gIH0gPSBwcm9wcztcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldENvbGxpZGVyKCk7XG4gICAgaWYgKGNvbGxpZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxpc2lvbjogY29sbGlzaW9uRXZlbnRzQWN0aXZlLFxuICAgICAgICBjb250YWN0Rm9yY2U6IGNvbnRhY3RGb3JjZUV2ZW50c0FjdGl2ZVxuICAgICAgfSA9IGdldEFjdGl2ZUNvbGxpc2lvbkV2ZW50c0Zyb21Qcm9wcyhwcm9wcyk7XG4gICAgICBjb25zdCBoYXNDb2xsaXNpb25FdmVudCA9IGNvbGxpc2lvbkV2ZW50c0FjdGl2ZSB8fCBhY3RpdmVFdmVudHMuY29sbGlzaW9uO1xuICAgICAgY29uc3QgaGFzQ29udGFjdEZvcmNlRXZlbnQgPSBjb250YWN0Rm9yY2VFdmVudHNBY3RpdmUgfHwgYWN0aXZlRXZlbnRzLmNvbnRhY3RGb3JjZTtcbiAgICAgIGlmIChoYXNDb2xsaXNpb25FdmVudCAmJiBoYXNDb250YWN0Rm9yY2VFdmVudCkge1xuICAgICAgICBjb2xsaWRlci5zZXRBY3RpdmVFdmVudHMoQWN0aXZlRXZlbnRzLkNPTExJU0lPTl9FVkVOVFMgfCBBY3RpdmVFdmVudHMuQ09OVEFDVF9GT1JDRV9FVkVOVFMpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDb2xsaXNpb25FdmVudCkge1xuICAgICAgICBjb2xsaWRlci5zZXRBY3RpdmVFdmVudHMoQWN0aXZlRXZlbnRzLkNPTExJU0lPTl9FVkVOVFMpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDb250YWN0Rm9yY2VFdmVudCkge1xuICAgICAgICBjb2xsaWRlci5zZXRBY3RpdmVFdmVudHMoQWN0aXZlRXZlbnRzLkNPTlRBQ1RfRk9SQ0VfRVZFTlRTKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50cy5zZXQoY29sbGlkZXIuaGFuZGxlLCB7XG4gICAgICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgICAgICBvbkNvbnRhY3RGb3JjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY29sbGlkZXIpIHtcbiAgICAgICAgZXZlbnRzLmRlbGV0ZShjb2xsaWRlci5oYW5kbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbkNvbGxpc2lvbkVudGVyLCBvbkNvbGxpc2lvbkV4aXQsIG9uSW50ZXJzZWN0aW9uRW50ZXIsIG9uSW50ZXJzZWN0aW9uRXhpdCwgb25Db250YWN0Rm9yY2UsIGFjdGl2ZUV2ZW50c10pO1xufTtcbmNvbnN0IGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlciA9IChwcm9wcyA9IHt9KSA9PiB7XG4gIGNvbnN0IHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQyKTtcbiAgcmV0dXJuIHJlc3Q7XG59O1xuXG4vLyBVdGlsc1xuY29uc3QgdXNlTXV0YWJsZUNhbGxiYWNrID0gZm4gPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0sIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufTtcblxuLy8gRXh0ZXJuYWwgaG9va3Ncbi8qKlxuICogRXhwb3NlcyB0aGUgUmFwaWVyIGNvbnRleHQsIGFuZCB3b3JsZFxuICogQGNhdGVnb3J5IEhvb2tzXG4gKi9cbmNvbnN0IHVzZVJhcGllciA9ICgpID0+IHtcbiAgY29uc3QgcmFwaWVyID0gdXNlQ29udGV4dChyYXBpZXJDb250ZXh0KTtcbiAgaWYgKCFyYXBpZXIpIHRocm93IG5ldyBFcnJvcihcInJlYWN0LXRocmVlLXJhcGllcjogdXNlUmFwaWVyIG11c3QgYmUgdXNlZCB3aXRoaW4gPFBoeXNpY3MgLz4hXCIpO1xuICByZXR1cm4gcmFwaWVyO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgYmVmb3JlIHRoZSBwaHlzaWNzIHN0ZXBcbiAqIEBjYXRlZ29yeSBIb29rc1xuICovXG5jb25zdCB1c2VCZWZvcmVQaHlzaWNzU3RlcCA9IGNhbGxiYWNrID0+IHtcbiAgY29uc3Qge1xuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3NcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuYWRkKHJlZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuZGVsZXRlKHJlZik7XG4gICAgfTtcbiAgfSwgW10pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHBoeXNpY3Mgc3RlcFxuICogQGNhdGVnb3J5IEhvb2tzXG4gKi9cbmNvbnN0IHVzZUFmdGVyUGh5c2ljc1N0ZXAgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IHtcbiAgICBhZnRlclN0ZXBDYWxsYmFja3NcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFmdGVyU3RlcENhbGxiYWNrcy5hZGQocmVmKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLmRlbGV0ZShyZWYpO1xuICAgIH07XG4gIH0sIFtdKTtcbn07XG5cbi8vIEludGVybmFsIGhvb2tzXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCB1c2VDaGlsZENvbGxpZGVyUHJvcHMgPSAocmVmLCBvcHRpb25zLCBpZ25vcmVNZXNoQ29sbGlkZXJzID0gdHJ1ZSkgPT4ge1xuICBjb25zdCBbY29sbGlkZXJQcm9wcywgc2V0Q29sbGlkZXJQcm9wc10gPSB1c2VTdGF0ZShbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb2JqZWN0ID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKG9iamVjdCAmJiBvcHRpb25zLmNvbGxpZGVycyAhPT0gZmFsc2UpIHtcbiAgICAgIHNldENvbGxpZGVyUHJvcHMoY3JlYXRlQ29sbGlkZXJQcm9wc0Zyb21DaGlsZHJlbih7XG4gICAgICAgIG9iamVjdDogcmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGlnbm9yZU1lc2hDb2xsaWRlcnNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLmNvbGxpZGVyc10pO1xuICByZXR1cm4gY29sbGlkZXJQcm9wcztcbn07XG5cbmNvbnN0IERlYnVnID0gLyojX19QVVJFX18qL21lbW8oKCkgPT4ge1xuICBjb25zdCB7XG4gICAgd29ybGRcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBjb25zdCBtZXNoID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFtZXNoKSByZXR1cm47XG4gICAgY29uc3QgYnVmZmVycyA9IHdvcmxkLmRlYnVnUmVuZGVyKCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcnMudmVydGljZXMsIDMpKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcnMuY29sb3JzLCA0KSk7XG4gICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgbWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lU2VnbWVudHNcIiwge1xuICAgIHJlZjogcmVmLFxuICAgIGZydXN0dW1DdWxsZWQ6IGZhbHNlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZUJhc2ljTWF0ZXJpYWxcIiwge1xuICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICB2ZXJ0ZXhDb2xvcnM6IHRydWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIiwgbnVsbCkpKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSB0aGF0IHdpbGwgY3JlYXRlIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjbGFzc1xuICogd2hlbiBhIHByb3BlcnR5IGlzIGFjY2Vzc2VkLCBhbmQgbm90IGJlZm9yZS5cbiAqXG4gKiBAcmV0dXJucyBBIHByb3h5IGFuZCBhIHJlc2V0IGZ1bmN0aW9uLCBzbyB0aGF0IHRoZSBpbnN0YW5jZSBjYW4gY3JlYXRlZCBhZ2FpblxuICovXG5jb25zdCBjcmVhdGVTaW5nbGV0b25Qcm94eSA9IGNyZWF0ZUluc3RhbmNlID0+IHtcbiAgbGV0IGluc3RhbmNlO1xuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGluc3RhbmNlLCBwcm9wKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LnNldChpbnN0YW5jZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIGhhbmRsZXIpO1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBpbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfTtcbiAgY29uc3Qgc2V0ID0gbmV3SW5zdGFuY2UgPT4ge1xuICAgIGluc3RhbmNlID0gbmV3SW5zdGFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcHJveHkgYW5kIGEgcmVzZXQgZnVuY3Rpb25cbiAgICovXG4gIHJldHVybiB7XG4gICAgcHJveHksXG4gICAgcmVzZXQsXG4gICAgc2V0XG4gIH07XG59O1xuXG5jb25zdCByYXBpZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlID0gKHRhcmdldCwgb3RoZXIpID0+IHtcbiAgdmFyIF90YXJnZXQkY29sbGlkZXIkc3RhdCwgX3RhcmdldCRyaWdpZEJvZHkkc3RhLCBfb3RoZXIkY29sbGlkZXIkc3RhdGUsIF9vdGhlciRyaWdpZEJvZHkkc3RhdCwgX290aGVyJGNvbGxpZGVyJHN0YXRlMiwgX290aGVyJHJpZ2lkQm9keSRzdGF0MjtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IHtcbiAgICAgIHJpZ2lkQm9keTogdGFyZ2V0LnJpZ2lkQm9keS5vYmplY3QsXG4gICAgICBjb2xsaWRlcjogdGFyZ2V0LmNvbGxpZGVyLm9iamVjdCxcbiAgICAgIGNvbGxpZGVyT2JqZWN0OiAoX3RhcmdldCRjb2xsaWRlciRzdGF0ID0gdGFyZ2V0LmNvbGxpZGVyLnN0YXRlKSA9PT0gbnVsbCB8fCBfdGFyZ2V0JGNvbGxpZGVyJHN0YXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YXJnZXQkY29sbGlkZXIkc3RhdC5vYmplY3QsXG4gICAgICByaWdpZEJvZHlPYmplY3Q6IChfdGFyZ2V0JHJpZ2lkQm9keSRzdGEgPSB0YXJnZXQucmlnaWRCb2R5LnN0YXRlKSA9PT0gbnVsbCB8fCBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YXJnZXQkcmlnaWRCb2R5JHN0YS5vYmplY3RcbiAgICB9LFxuICAgIG90aGVyOiB7XG4gICAgICByaWdpZEJvZHk6IG90aGVyLnJpZ2lkQm9keS5vYmplY3QsXG4gICAgICBjb2xsaWRlcjogb3RoZXIuY29sbGlkZXIub2JqZWN0LFxuICAgICAgY29sbGlkZXJPYmplY3Q6IChfb3RoZXIkY29sbGlkZXIkc3RhdGUgPSBvdGhlci5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJGNvbGxpZGVyJHN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkY29sbGlkZXIkc3RhdGUub2JqZWN0LFxuICAgICAgcmlnaWRCb2R5T2JqZWN0OiAoX290aGVyJHJpZ2lkQm9keSRzdGF0ID0gb3RoZXIucmlnaWRCb2R5LnN0YXRlKSA9PT0gbnVsbCB8fCBfb3RoZXIkcmlnaWRCb2R5JHN0YXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vdGhlciRyaWdpZEJvZHkkc3RhdC5vYmplY3RcbiAgICB9LFxuICAgIHJpZ2lkQm9keTogb3RoZXIucmlnaWRCb2R5Lm9iamVjdCxcbiAgICBjb2xsaWRlcjogb3RoZXIuY29sbGlkZXIub2JqZWN0LFxuICAgIGNvbGxpZGVyT2JqZWN0OiAoX290aGVyJGNvbGxpZGVyJHN0YXRlMiA9IG90aGVyLmNvbGxpZGVyLnN0YXRlKSA9PT0gbnVsbCB8fCBfb3RoZXIkY29sbGlkZXIkc3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkY29sbGlkZXIkc3RhdGUyLm9iamVjdCxcbiAgICByaWdpZEJvZHlPYmplY3Q6IChfb3RoZXIkcmlnaWRCb2R5JHN0YXQyID0gb3RoZXIucmlnaWRCb2R5LnN0YXRlKSA9PT0gbnVsbCB8fCBfb3RoZXIkcmlnaWRCb2R5JHN0YXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkcmlnaWRCb2R5JHN0YXQyLm9iamVjdFxuICB9O1xufTtcbmNvbnN0IGltcG9ydFJhcGllciA9IGFzeW5jICgpID0+IHtcbiAgbGV0IHIgPSBhd2FpdCBpbXBvcnQoJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnKTtcbiAgYXdhaXQgci5pbml0KCk7XG4gIHJldHVybiByO1xufTtcbi8qKlxuICogVGhlIG1haW4gcGh5c2ljcyBjb21wb25lbnQgdXNlZCB0byBjcmVhdGUgYSBwaHlzaWNzIHdvcmxkLlxuICogQGNhdGVnb3J5IENvbXBvbmVudHNcbiAqL1xuY29uc3QgUGh5c2ljcyA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbGxpZGVycyA9IFwiY3Vib2lkXCIsXG4gICAgY2hpbGRyZW4sXG4gICAgdGltZVN0ZXAgPSAxIC8gNjAsXG4gICAgcGF1c2VkID0gZmFsc2UsXG4gICAgaW50ZXJwb2xhdGUgPSB0cnVlLFxuICAgIHVwZGF0ZVByaW9yaXR5LFxuICAgIHVwZGF0ZUxvb3AgPSBcImZvbGxvd1wiLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gICAgZ3Jhdml0eSA9IFswLCAtOS44MSwgMF0sXG4gICAgYWxsb3dlZExpbmVhckVycm9yID0gMC4wMDEsXG4gICAgcHJlZGljdGlvbkRpc3RhbmNlID0gMC4wMDIsXG4gICAgbnVtU29sdmVySXRlcmF0aW9ucyA9IDQsXG4gICAgbnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucyA9IDQsXG4gICAgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zID0gMSxcbiAgICBtaW5Jc2xhbmRTaXplID0gMTI4LFxuICAgIG1heENjZFN1YnN0ZXBzID0gMSxcbiAgICBjb250YWN0TmF0dXJhbEZyZXF1ZW5jeSA9IDMwLFxuICAgIGxlbmd0aFVuaXQgPSAxXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcmFwaWVyID0gc3VzcGVuZChpbXBvcnRSYXBpZXIsIFtcIkByZWFjdC10aGVlL3JhcGllclwiLCBpbXBvcnRSYXBpZXJdKTtcbiAgY29uc3Qge1xuICAgIGludmFsaWRhdGVcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGNvbnN0IHJpZ2lkQm9keVN0YXRlcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNvbGxpZGVyU3RhdGVzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgcmlnaWRCb2R5RXZlbnRzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgY29sbGlkZXJFdmVudHMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBldmVudFF1ZXVlID0gdXNlQ29uc3QoKCkgPT4gbmV3IEV2ZW50UXVldWUoZmFsc2UpKTtcbiAgY29uc3QgYmVmb3JlU3RlcENhbGxiYWNrcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBTZXQoKSk7XG4gIGNvbnN0IGFmdGVyU3RlcENhbGxiYWNrcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBTZXQoKSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIHRoZSB3b3JsZFxuICAgKiBUaGlzIGNyZWF0ZXMgYSBzaW5nbGV0b24gcHJveHksIHNvIHRoYXQgdGhlIHdvcmxkIGlzIG9ubHkgY3JlYXRlZCB3aGVuXG4gICAqIHNvbWV0aGluZyB3aXRoaW4gaXQgaXMgYWNjZXNzZWQuXG4gICAqL1xuICBjb25zdCB7XG4gICAgcHJveHk6IHdvcmxkUHJveHksXG4gICAgcmVzZXQ6IHJlc2V0V29ybGRQcm94eSxcbiAgICBzZXQ6IHNldFdvcmxkUHJveHlcbiAgfSA9IHVzZUNvbnN0KCgpID0+IGNyZWF0ZVNpbmdsZXRvblByb3h5KCgpID0+IG5ldyByYXBpZXIuV29ybGQodmVjdG9yQXJyYXlUb1ZlY3RvcjMoZ3Jhdml0eSkpKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdvcmxkUHJveHkuZnJlZSgpO1xuICAgICAgcmVzZXRXb3JsZFByb3h5KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIFVwZGF0ZSBtdXRhYmxlIHByb3BzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd29ybGRQcm94eS5ncmF2aXR5ID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGdyYXZpdHkpO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bVNvbHZlckl0ZXJhdGlvbnMgPSBudW1Tb2x2ZXJJdGVyYXRpb25zO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMgPSBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bUludGVybmFsUGdzSXRlcmF0aW9ucyA9IG51bUludGVybmFsUGdzSXRlcmF0aW9ucztcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5ub3JtYWxpemVkQWxsb3dlZExpbmVhckVycm9yID0gYWxsb3dlZExpbmVhckVycm9yO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1pbklzbGFuZFNpemUgPSBtaW5Jc2xhbmRTaXplO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1heENjZFN1YnN0ZXBzID0gbWF4Q2NkU3Vic3RlcHM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubm9ybWFsaXplZFByZWRpY3Rpb25EaXN0YW5jZSA9IHByZWRpY3Rpb25EaXN0YW5jZTtcbiAgICB3b3JsZFByb3h5Lmxlbmd0aFVuaXQgPSBsZW5ndGhVbml0O1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLmNvbnRhY3RfbmF0dXJhbF9mcmVxdWVuY3kgPSBjb250YWN0TmF0dXJhbEZyZXF1ZW5jeTtcbiAgfSwgW3dvcmxkUHJveHksIC4uLmdyYXZpdHksIG51bVNvbHZlckl0ZXJhdGlvbnMsIG51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMsIG51bUludGVybmFsUGdzSXRlcmF0aW9ucywgYWxsb3dlZExpbmVhckVycm9yLCBtaW5Jc2xhbmRTaXplLCBtYXhDY2RTdWJzdGVwcywgcHJlZGljdGlvbkRpc3RhbmNlLCBsZW5ndGhVbml0LCBjb250YWN0TmF0dXJhbEZyZXF1ZW5jeV0pO1xuICBjb25zdCBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUgPSB1c2VDYWxsYmFjayhoYW5kbGUgPT4ge1xuICAgIHZhciBfY29sbGlkZXIkcGFyZW50O1xuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGRQcm94eS5nZXRDb2xsaWRlcihoYW5kbGUpO1xuICAgIGNvbnN0IGNvbEV2ZW50cyA9IGNvbGxpZGVyRXZlbnRzLmdldChoYW5kbGUpO1xuICAgIGNvbnN0IGNvbGxpZGVyU3RhdGUgPSBjb2xsaWRlclN0YXRlcy5nZXQoaGFuZGxlKTtcbiAgICBjb25zdCByaWdpZEJvZHlIYW5kbGUgPSBjb2xsaWRlciA9PT0gbnVsbCB8fCBjb2xsaWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2xsaWRlciRwYXJlbnQgPSBjb2xsaWRlci5wYXJlbnQoKSkgPT09IG51bGwgfHwgX2NvbGxpZGVyJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxpZGVyJHBhcmVudC5oYW5kbGU7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyB3b3JsZFByb3h5LmdldFJpZ2lkQm9keShyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJiRXZlbnRzID0gcmlnaWRCb2R5ICYmIHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gcmlnaWRCb2R5RXZlbnRzLmdldChyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJpZ2lkQm9keVN0YXRlID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyByaWdpZEJvZHlTdGF0ZXMuZ2V0KHJpZ2lkQm9keUhhbmRsZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgY29sbGlkZXI6IHtcbiAgICAgICAgb2JqZWN0OiBjb2xsaWRlcixcbiAgICAgICAgZXZlbnRzOiBjb2xFdmVudHMsXG4gICAgICAgIHN0YXRlOiBjb2xsaWRlclN0YXRlXG4gICAgICB9LFxuICAgICAgcmlnaWRCb2R5OiB7XG4gICAgICAgIG9iamVjdDogcmlnaWRCb2R5LFxuICAgICAgICBldmVudHM6IHJiRXZlbnRzLFxuICAgICAgICBzdGF0ZTogcmlnaWRCb2R5U3RhdGVcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sIFtdKTtcbiAgY29uc3QgW3N0ZXBwaW5nU3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIHByZXZpb3VzU3RhdGU6IHt9LFxuICAgIGFjY3VtdWxhdG9yOiAwXG4gIH0pO1xuICBjb25zdCBzdGVwID0gdXNlQ2FsbGJhY2soZHQgPT4ge1xuICAgIGNvbnN0IHdvcmxkID0gd29ybGRQcm94eTtcblxuICAgIC8qIENoZWNrIGlmIHRoZSB0aW1lc3RlcCBpcyBzdXBwb3NlZCB0byBiZSB2YXJpYWJsZS4gV2UnbGwgZG8gdGhpcyBoZXJlXG4gICAgICBvbmNlIHNvIHdlIGRvbid0IGhhdmUgdG8gc3RyaW5nLWNoZWNrIGV2ZXJ5IGZyYW1lLiAqL1xuICAgIGNvbnN0IHRpbWVTdGVwVmFyaWFibGUgPSB0aW1lU3RlcCA9PT0gXCJ2YXJ5XCI7XG5cbiAgICAvKipcbiAgICAgKiBGaXhlZCB0aW1lU3RlcCBzaW11bGF0aW9uIHByb2dyZXNzaW9uXG4gICAgICogQHNlZSBodHRwczovL2dhZmZlcm9uZ2FtZXMuY29tL3Bvc3QvZml4X3lvdXJfdGltZXN0ZXAvXG4gICAgICovXG5cbiAgICBjb25zdCBjbGFtcGVkRGVsdGEgPSBNYXRoVXRpbHMuY2xhbXAoZHQsIDAsIDAuNSk7XG4gICAgY29uc3Qgc3RlcFdvcmxkID0gZGVsdGEgPT4ge1xuICAgICAgLy8gVHJpZ2dlciBiZWZvcmVTdGVwIGNhbGxiYWNrc1xuICAgICAgYmVmb3JlU3RlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2suY3VycmVudCh3b3JsZCk7XG4gICAgICB9KTtcbiAgICAgIHdvcmxkLnRpbWVzdGVwID0gZGVsdGE7XG4gICAgICB3b3JsZC5zdGVwKGV2ZW50UXVldWUpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGFmdGVyU3RlcCBjYWxsYmFja3NcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2suY3VycmVudCh3b3JsZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aW1lU3RlcFZhcmlhYmxlKSB7XG4gICAgICBzdGVwV29ybGQoY2xhbXBlZERlbHRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9uJ3Qgc3RlcCB0aW1lIGZvcndhcmRzIGlmIHBhdXNlZFxuICAgICAgLy8gSW5jcmVhc2UgYWNjdW11bGF0b3JcbiAgICAgIHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgKz0gY2xhbXBlZERlbHRhO1xuICAgICAgd2hpbGUgKHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgPj0gdGltZVN0ZXApIHtcbiAgICAgICAgLy8gU2V0IHVwIHByZXZpb3VzIHN0YXRlXG4gICAgICAgIC8vIG5lZWRlZCBmb3IgYWNjdXJhdGUgaW50ZXJwb2xhdGlvbnMgaWYgdGhlIHdvcmxkIHN0ZXBzIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgIHN0ZXBwaW5nU3RhdGUucHJldmlvdXNTdGF0ZSA9IHt9O1xuICAgICAgICAgIHdvcmxkLmZvckVhY2hSaWdpZEJvZHkoYm9keSA9PiB7XG4gICAgICAgICAgICBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbYm9keS5oYW5kbGVdID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYm9keS50cmFuc2xhdGlvbigpLFxuICAgICAgICAgICAgICByb3RhdGlvbjogYm9keS5yb3RhdGlvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBXb3JsZCh0aW1lU3RlcCk7XG4gICAgICAgIHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgLT0gdGltZVN0ZXA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRpb25BbHBoYSA9IHRpbWVTdGVwVmFyaWFibGUgfHwgIWludGVycG9sYXRlIHx8IHBhdXNlZCA/IDEgOiBzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yIC8gdGltZVN0ZXA7XG5cbiAgICAvLyBVcGRhdGUgbWVzaGVzXG4gICAgcmlnaWRCb2R5U3RhdGVzLmZvckVhY2goKHN0YXRlLCBoYW5kbGUpID0+IHtcbiAgICAgIGNvbnN0IHJpZ2lkQm9keSA9IHdvcmxkLmdldFJpZ2lkQm9keShoYW5kbGUpO1xuICAgICAgY29uc3QgZXZlbnRzID0gcmlnaWRCb2R5RXZlbnRzLmdldChoYW5kbGUpO1xuICAgICAgaWYgKGV2ZW50cyAhPT0gbnVsbCAmJiBldmVudHMgIT09IHZvaWQgMCAmJiBldmVudHMub25TbGVlcCB8fCBldmVudHMgIT09IG51bGwgJiYgZXZlbnRzICE9PSB2b2lkIDAgJiYgZXZlbnRzLm9uV2FrZSkge1xuICAgICAgICBpZiAocmlnaWRCb2R5LmlzU2xlZXBpbmcoKSAmJiAhc3RhdGUuaXNTbGVlcGluZykge1xuICAgICAgICAgIHZhciBfZXZlbnRzJG9uU2xlZXA7XG4gICAgICAgICAgZXZlbnRzID09PSBudWxsIHx8IGV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudHMkb25TbGVlcCA9IGV2ZW50cy5vblNsZWVwKSA9PT0gbnVsbCB8fCBfZXZlbnRzJG9uU2xlZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudHMkb25TbGVlcC5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyaWdpZEJvZHkuaXNTbGVlcGluZygpICYmIHN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyRvbldha2U7XG4gICAgICAgICAgZXZlbnRzID09PSBudWxsIHx8IGV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudHMkb25XYWtlID0gZXZlbnRzLm9uV2FrZSkgPT09IG51bGwgfHwgX2V2ZW50cyRvbldha2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudHMkb25XYWtlLmNhbGwoZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gcmlnaWRCb2R5LmlzU2xlZXBpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmlnaWRCb2R5IHx8IHJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgIShcImlzSW5zdGFuY2VkTWVzaFwiIGluIHN0YXRlLm9iamVjdCkgfHwgIXN0YXRlLnNldE1hdHJpeCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE5ldyBzdGF0ZXNcbiAgICAgIGxldCB0ID0gcmlnaWRCb2R5LnRyYW5zbGF0aW9uKCk7XG4gICAgICBsZXQgciA9IHJpZ2lkQm9keS5yb3RhdGlvbigpO1xuICAgICAgbGV0IHByZXZpb3VzU3RhdGUgPSBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbaGFuZGxlXTtcbiAgICAgIGlmIChwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgIC8vIEdldCBwcmV2aW91cyBzaW11bGF0ZWQgd29ybGQgcG9zaXRpb25cbiAgICAgICAgX21hdHJpeDQuY29tcG9zZShwcmV2aW91c1N0YXRlLnBvc2l0aW9uLCByYXBpZXJRdWF0ZXJuaW9uVG9RdWF0ZXJuaW9uKHByZXZpb3VzU3RhdGUucm90YXRpb24pLCBzdGF0ZS5zY2FsZSkucHJlbXVsdGlwbHkoc3RhdGUuaW52ZXJ0ZWRXb3JsZE1hdHJpeCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuXG4gICAgICAgIC8vIEFwcGx5IHByZXZpb3VzIHRpY2sgcG9zaXRpb25cbiAgICAgICAgaWYgKHN0YXRlLm1lc2hUeXBlID09IFwibWVzaFwiKSB7XG4gICAgICAgICAgc3RhdGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoX3Bvc2l0aW9uKTtcbiAgICAgICAgICBzdGF0ZS5vYmplY3QucXVhdGVybmlvbi5jb3B5KF9yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IG5ldyBwb3NpdGlvblxuICAgICAgX21hdHJpeDQuY29tcG9zZSh0LCByYXBpZXJRdWF0ZXJuaW9uVG9RdWF0ZXJuaW9uKHIpLCBzdGF0ZS5zY2FsZSkucHJlbXVsdGlwbHkoc3RhdGUuaW52ZXJ0ZWRXb3JsZE1hdHJpeCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuICAgICAgaWYgKHN0YXRlLm1lc2hUeXBlID09IFwiaW5zdGFuY2VkTWVzaFwiKSB7XG4gICAgICAgIHN0YXRlLnNldE1hdHJpeChfbWF0cml4NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSB0byBuZXcgcG9zaXRpb25cbiAgICAgICAgc3RhdGUub2JqZWN0LnBvc2l0aW9uLmxlcnAoX3Bvc2l0aW9uLCBpbnRlcnBvbGF0aW9uQWxwaGEpO1xuICAgICAgICBzdGF0ZS5vYmplY3QucXVhdGVybmlvbi5zbGVycChfcm90YXRpb24sIGludGVycG9sYXRpb25BbHBoYSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXZlbnRRdWV1ZS5kcmFpbkNvbGxpc2lvbkV2ZW50cygoaGFuZGxlMSwgaGFuZGxlMiwgc3RhcnRlZCkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlMSA9IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZShoYW5kbGUxKTtcbiAgICAgIGNvbnN0IHNvdXJjZTIgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoaGFuZGxlMik7XG5cbiAgICAgIC8vIENvbGxpc2lvbiBFdmVudHNcbiAgICAgIGlmICghKHNvdXJjZTEgIT09IG51bGwgJiYgc291cmNlMSAhPT0gdm9pZCAwICYmIHNvdXJjZTEuY29sbGlkZXIub2JqZWN0KSB8fCAhKHNvdXJjZTIgIT09IG51bGwgJiYgc291cmNlMiAhPT0gdm9pZCAwICYmIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMSA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTEsIHNvdXJjZTIpO1xuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDIgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UyLCBzb3VyY2UxKTtcbiAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgIHdvcmxkLmNvbnRhY3RQYWlyKHNvdXJjZTEuY29sbGlkZXIub2JqZWN0LCBzb3VyY2UyLmNvbGxpZGVyLm9iamVjdCwgKG1hbmlmb2xkLCBmbGlwcGVkKSA9PiB7XG4gICAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldiwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2LCBfc291cmNlMiRyaWdpZEJvZHkkZXYyLCBfc291cmNlMSRjb2xsaWRlciRldmUsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTIsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZSwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMjtcbiAgICAgICAgICAvKiBSaWdpZEJvZHkgZXZlbnRzICovXG4gICAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldiA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldi5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXYyLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXYgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjIgPSBfc291cmNlMiRyaWdpZEJvZHkkZXYub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2Mi5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIC8qIENvbGxpZGVyIGV2ZW50cyAqL1xuICAgICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmUgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmUgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDIpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYzLCBfc291cmNlMSRyaWdpZEJvZHkkZXY0LCBfc291cmNlMiRyaWdpZEJvZHkkZXYzLCBfc291cmNlMiRyaWdpZEJvZHkkZXY0LCBfc291cmNlMSRjb2xsaWRlciRldmUzLCBfc291cmNlMSRjb2xsaWRlciRldmU0LCBfc291cmNlMiRjb2xsaWRlciRldmUzLCBfc291cmNlMiRjb2xsaWRlciRldmU0O1xuICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MyA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjQgPSBfc291cmNlMSRyaWdpZEJvZHkkZXYzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2NC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjMsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjMgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY0ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2My5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjQuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXYzLCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmUzID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU0ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlMy5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQuY2FsbChfc291cmNlMSRjb2xsaWRlciRldmUzLCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmUzID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU0ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlMy5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQuY2FsbChfc291cmNlMiRjb2xsaWRlciRldmUzLCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbnNvciBJbnRlcnNlY3Rpb25zXG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICBpZiAod29ybGQuaW50ZXJzZWN0aW9uUGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QpKSB7XG4gICAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTY7XG4gICAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldjUgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRyaWdpZEJvZHkkZXY2ID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2NS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXY2LmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSwgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXY1ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NiA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2Ni5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjUsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNSA9IHNvdXJjZTEuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNiA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlNi5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNSA9IHNvdXJjZTIuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNiA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlNi5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjcsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjgsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjcsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjgsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTgsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTg7XG4gICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXY3ID0gc291cmNlMS5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldjcub25JbnRlcnNlY3Rpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXY4LmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NywgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NyA9IHNvdXJjZTIucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjggPSBfc291cmNlMiRyaWdpZEJvZHkkZXY3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2OCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2OC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjcsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTggPSBfc291cmNlMSRjb2xsaWRlciRldmU3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlOC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTggPSBfc291cmNlMiRjb2xsaWRlciRldmU3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlOC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBldmVudFF1ZXVlLmRyYWluQ29udGFjdEZvcmNlRXZlbnRzKGV2ZW50ID0+IHtcbiAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXY5LCBfc291cmNlMSRyaWdpZEJvZHkkZXYxMCwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2OSwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MTAsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTksIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwLCBfc291cmNlMiRjb2xsaWRlciRldmU5LCBfc291cmNlMiRjb2xsaWRlciRldmUxMDtcbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoZXZlbnQuY29sbGlkZXIxKCkpO1xuICAgICAgY29uc3Qgc291cmNlMiA9IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZShldmVudC5jb2xsaWRlcjIoKSk7XG5cbiAgICAgIC8vIENvbGxpc2lvbiBFdmVudHNcbiAgICAgIGlmICghKHNvdXJjZTEgIT09IG51bGwgJiYgc291cmNlMSAhPT0gdm9pZCAwICYmIHNvdXJjZTEuY29sbGlkZXIub2JqZWN0KSB8fCAhKHNvdXJjZTIgIT09IG51bGwgJiYgc291cmNlMiAhPT0gdm9pZCAwICYmIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMSA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTEsIHNvdXJjZTIpO1xuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDIgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UyLCBzb3VyY2UxKTtcbiAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXY5ID0gc291cmNlMS5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAgPSBfc291cmNlMSRyaWdpZEJvZHkkZXY5Lm9uQ29udGFjdEZvcmNlKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYxMCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAuY2FsbChfc291cmNlMSRyaWdpZEJvZHkkZXY5LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICB0b3RhbEZvcmNlOiBldmVudC50b3RhbEZvcmNlKCksXG4gICAgICAgIHRvdGFsRm9yY2VNYWduaXR1ZGU6IGV2ZW50LnRvdGFsRm9yY2VNYWduaXR1ZGUoKSxcbiAgICAgICAgbWF4Rm9yY2VEaXJlY3Rpb246IGV2ZW50Lm1heEZvcmNlRGlyZWN0aW9uKCksXG4gICAgICAgIG1heEZvcmNlTWFnbml0dWRlOiBldmVudC5tYXhGb3JjZU1hZ25pdHVkZSgpXG4gICAgICB9KSk7XG4gICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2OSA9IHNvdXJjZTIucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2OSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2OS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwLmNhbGwoX3NvdXJjZTIkcmlnaWRCb2R5JGV2OSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgICAgKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlOSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlOS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwLmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlOSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgICAgKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlOSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlOS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwLmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlOSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHdvcmxkLmZvckVhY2hBY3RpdmVSaWdpZEJvZHkoKCkgPT4ge1xuICAgICAgaW52YWxpZGF0ZSgpO1xuICAgIH0pO1xuICB9LCBbcGF1c2VkLCB0aW1lU3RlcCwgaW50ZXJwb2xhdGUsIHdvcmxkUHJveHldKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICByYXBpZXIsXG4gICAgd29ybGQ6IHdvcmxkUHJveHksXG4gICAgc2V0V29ybGQ6IHdvcmxkID0+IHtcbiAgICAgIHNldFdvcmxkUHJveHkod29ybGQpO1xuICAgIH0sXG4gICAgcGh5c2ljc09wdGlvbnM6IHtcbiAgICAgIGNvbGxpZGVycyxcbiAgICAgIGdyYXZpdHlcbiAgICB9LFxuICAgIHJpZ2lkQm9keVN0YXRlcyxcbiAgICBjb2xsaWRlclN0YXRlcyxcbiAgICByaWdpZEJvZHlFdmVudHMsXG4gICAgY29sbGlkZXJFdmVudHMsXG4gICAgYmVmb3JlU3RlcENhbGxiYWNrcyxcbiAgICBhZnRlclN0ZXBDYWxsYmFja3MsXG4gICAgaXNQYXVzZWQ6IHBhdXNlZCxcbiAgICBpc0RlYnVnOiBkZWJ1ZyxcbiAgICBzdGVwXG4gIH0pLCBbcGF1c2VkLCBzdGVwLCBkZWJ1ZywgY29sbGlkZXJzLCBncmF2aXR5XSk7XG4gIGNvbnN0IHN0ZXBDYWxsYmFjayA9IHVzZUNhbGxiYWNrKGRlbHRhID0+IHtcbiAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgc3RlcChkZWx0YSk7XG4gICAgfVxuICB9LCBbcGF1c2VkLCBzdGVwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyYXBpZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRnJhbWVTdGVwcGVyJDEsIHtcbiAgICBvblN0ZXA6IHN0ZXBDYWxsYmFjayxcbiAgICB0eXBlOiB1cGRhdGVMb29wLFxuICAgIHVwZGF0ZVByaW9yaXR5OiB1cGRhdGVQcmlvcml0eVxuICB9KSwgZGVidWcgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVidWcsIG51bGwpLCBjaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLy8gTmVlZCB0byBjYXRjaCB0aGUgY2FzZSB3aGVyZSBmb3J3YXJkZWRSZWYgaXMgYSBmdW5jdGlvbi4uLiBob3cgdG8gZG8gdGhhdD9cbmNvbnN0IHVzZUZvcndhcmRlZFJlZiA9IChmb3J3YXJkZWRSZWYsIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgY29uc3QgaW5uZXJSZWYgPSB1c2VSZWYoZGVmYXVsdFZhbHVlKTtcblxuICAvLyBVcGRhdGUgdGhlIGZvcndhcmRlZCByZWYgd2hlbiB0aGUgaW5uZXIgcmVmIGNoYW5nZXNcbiAgaWYgKGZvcndhcmRlZFJlZiAmJiB0eXBlb2YgZm9yd2FyZGVkUmVmICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIWZvcndhcmRlZFJlZi5jdXJyZW50KSB7XG4gICAgICBmb3J3YXJkZWRSZWYuY3VycmVudCA9IGlubmVyUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmb3J3YXJkZWRSZWY7XG4gIH1cbiAgcmV0dXJuIGlubmVyUmVmO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSBhbiBpbnN0YW5jZSBhbmQgcmV0dXJuIGEgc2FmZSBnZXR0ZXJcbiAqL1xuY29uc3QgdXNlSW1wZXJhdGl2ZUluc3RhbmNlID0gKGNyZWF0ZUZuLCBkZXN0cm95Rm4sIGRlcGVuZGVuY3lMaXN0KSA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICBjb25zdCBnZXRJbnN0YW5jZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICByZWYuY3VycmVudCA9IGNyZWF0ZUZuKCk7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgfSwgZGVwZW5kZW5jeUxpc3QpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNhdmUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gYW5kIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiBkZXN0cm95Rm4oaW5zdGFuY2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZXN0cm95KCk7XG4gICAgICByZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9LCBbZ2V0SW5zdGFuY2VdKTtcbiAgcmV0dXJuIGdldEluc3RhbmNlO1xufTtcblxuY29uc3QgcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIHZhciBfb3B0aW9ucyRjYW5TbGVlcDtcbiAgY29uc3QgdHlwZSA9IHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgfHwgXCJkeW5hbWljXCIpO1xuICBjb25zdCBkZXNjID0gbmV3IFJpZ2lkQm9keURlc2ModHlwZSk7XG5cbiAgLy8gQXBwbHkgaW1tdXRhYmxlIG9wdGlvbnNcbiAgZGVzYy5jYW5TbGVlcCA9IChfb3B0aW9ucyRjYW5TbGVlcCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYW5TbGVlcCkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FuU2xlZXAgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhblNsZWVwIDogdHJ1ZTtcbiAgcmV0dXJuIGRlc2M7XG59O1xuY29uc3QgY3JlYXRlUmlnaWRCb2R5U3RhdGUgPSAoe1xuICByaWdpZEJvZHksXG4gIG9iamVjdCxcbiAgc2V0TWF0cml4LFxuICBnZXRNYXRyaXgsXG4gIHdvcmxkU2NhbGUsXG4gIG1lc2hUeXBlOiBfbWVzaFR5cGUgPSBcIm1lc2hcIlxufSkgPT4ge1xuICBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICBjb25zdCBpbnZlcnRlZFdvcmxkTWF0cml4ID0gb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZC5jbG9uZSgpLmludmVydCgpO1xuICByZXR1cm4ge1xuICAgIG9iamVjdCxcbiAgICByaWdpZEJvZHksXG4gICAgaW52ZXJ0ZWRXb3JsZE1hdHJpeCxcbiAgICBzZXRNYXRyaXg6IHNldE1hdHJpeCA/IHNldE1hdHJpeCA6IG1hdHJpeCA9PiB7XG4gICAgICBvYmplY3QubWF0cml4LmNvcHkobWF0cml4KTtcbiAgICB9LFxuICAgIGdldE1hdHJpeDogZ2V0TWF0cml4ID8gZ2V0TWF0cml4IDogbWF0cml4ID0+IG1hdHJpeC5jb3B5KG9iamVjdC5tYXRyaXgpLFxuICAgIHNjYWxlOiB3b3JsZFNjYWxlIHx8IG9iamVjdC5nZXRXb3JsZFNjYWxlKF9zY2FsZSkuY2xvbmUoKSxcbiAgICBpc1NsZWVwaW5nOiBmYWxzZSxcbiAgICBtZXNoVHlwZTogX21lc2hUeXBlXG4gIH07XG59O1xuY29uc3QgaW1tdXRhYmxlUmlnaWRCb2R5T3B0aW9ucyA9IFtcImFyZ3NcIiwgXCJjb2xsaWRlcnNcIiwgXCJjYW5TbGVlcFwiXTtcbmNvbnN0IG11dGFibGVSaWdpZEJvZHlPcHRpb25zID0ge1xuICBncmF2aXR5U2NhbGU6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRHcmF2aXR5U2NhbGUodmFsdWUsIHRydWUpO1xuICB9LFxuICBhZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucyhyYiwgdmFsdWUpIHtcbiAgICByYi5zZXRBZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucyh2YWx1ZSk7XG4gIH0sXG4gIGxpbmVhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRMaW5lYXJEYW1waW5nKHZhbHVlKTtcbiAgfSxcbiAgYW5ndWxhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRBbmd1bGFyRGFtcGluZyh2YWx1ZSk7XG4gIH0sXG4gIGRvbWluYW5jZUdyb3VwOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0RG9taW5hbmNlR3JvdXAodmFsdWUpO1xuICB9LFxuICBlbmFibGVkUm90YXRpb25zOiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldEVuYWJsZWRSb3RhdGlvbnMoeCwgeSwgeiwgdHJ1ZSk7XG4gIH0sXG4gIGVuYWJsZWRUcmFuc2xhdGlvbnM6IChyYiwgW3gsIHksIHpdKSA9PiB7XG4gICAgcmIuc2V0RW5hYmxlZFRyYW5zbGF0aW9ucyh4LCB5LCB6LCB0cnVlKTtcbiAgfSxcbiAgbG9ja1JvdGF0aW9uczogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmxvY2tSb3RhdGlvbnModmFsdWUsIHRydWUpO1xuICB9LFxuICBsb2NrVHJhbnNsYXRpb25zOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIubG9ja1RyYW5zbGF0aW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gIH0sXG4gIGFuZ3VsYXJWZWxvY2l0eTogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRBbmd2ZWwoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGxpbmVhclZlbG9jaXR5OiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldExpbnZlbCh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgY2NkOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuZW5hYmxlQ2NkKHZhbHVlKTtcbiAgfSxcbiAgc29mdENjZFByZWRpY3Rpb246IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRTb2Z0Q2NkUHJlZGljdGlvbih2YWx1ZSk7XG4gIH0sXG4gIHVzZXJEYXRhOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIudXNlckRhdGEgPSB2YWx1ZTtcbiAgfSxcbiAgdHlwZShyYiwgdmFsdWUpIHtcbiAgICByYi5zZXRCb2R5VHlwZShyaWdpZEJvZHlUeXBlRnJvbVN0cmluZyh2YWx1ZSksIHRydWUpO1xuICB9LFxuICBwb3NpdGlvbjogKCkgPT4ge30sXG4gIHJvdGF0aW9uOiAoKSA9PiB7fSxcbiAgcXVhdGVybmlvbjogKCkgPT4ge30sXG4gIHNjYWxlOiAoKSA9PiB7fVxufTtcbmNvbnN0IG11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzID0gT2JqZWN0LmtleXMobXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMpO1xuY29uc3Qgc2V0UmlnaWRCb2R5T3B0aW9ucyA9IChyaWdpZEJvZHksIG9wdGlvbnMsIHN0YXRlcywgdXBkYXRlVHJhbnNsYXRpb25zID0gdHJ1ZSkgPT4ge1xuICBpZiAoIXJpZ2lkQm9keSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQocmlnaWRCb2R5LmhhbmRsZSk7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh1cGRhdGVUcmFuc2xhdGlvbnMpIHtcbiAgICAgIHN0YXRlLm9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICBfbWF0cml4NC5jb3B5KHN0YXRlLm9iamVjdC5tYXRyaXhXb3JsZCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuICAgICAgcmlnaWRCb2R5LnNldFRyYW5zbGF0aW9uKF9wb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgcmlnaWRCb2R5LnNldFJvdGF0aW9uKF9yb3RhdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICBtdXRhYmxlUmlnaWRCb2R5T3B0aW9uS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnNba2V5XShyaWdpZEJvZHksIG9wdGlvbnNba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCB1c2VVcGRhdGVSaWdpZEJvZHlPcHRpb25zID0gKGdldFJpZ2lkQm9keSwgcHJvcHMsIHN0YXRlcywgdXBkYXRlVHJhbnNsYXRpb25zID0gdHJ1ZSkgPT4ge1xuICAvLyBUT0RPOiBJbXByb3ZlIHRoaXMsIHNwbGl0IGVhY2ggcHJvcCBpbnRvIGl0cyBvd24gZWZmZWN0XG4gIGNvbnN0IG11dGFibGVQcm9wc0FzRmxhdEFycmF5ID0gdXNlTWVtbygoKSA9PiBtdXRhYmxlUmlnaWRCb2R5T3B0aW9uS2V5cy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIHZlY3RvclRvVHVwbGUocHJvcHNba2V5XSk7XG4gIH0pLCBbcHJvcHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByaWdpZEJvZHkgPSBnZXRSaWdpZEJvZHkoKTtcbiAgICBzZXRSaWdpZEJvZHlPcHRpb25zKHJpZ2lkQm9keSwgcHJvcHMsIHN0YXRlcywgdXBkYXRlVHJhbnNsYXRpb25zKTtcbiAgfSwgbXV0YWJsZVByb3BzQXNGbGF0QXJyYXkpO1xufTtcbmNvbnN0IHVzZVJpZ2lkQm9keUV2ZW50cyA9IChnZXRSaWdpZEJvZHksIHByb3BzLCBldmVudHMpID0+IHtcbiAgY29uc3Qge1xuICAgIG9uV2FrZSxcbiAgICBvblNsZWVwLFxuICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgb25Db2xsaXNpb25FeGl0LFxuICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgIG9uQ29udGFjdEZvcmNlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZXZlbnRIYW5kbGVycyA9IHtcbiAgICBvbldha2UsXG4gICAgb25TbGVlcCxcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IGdldFJpZ2lkQm9keSgpO1xuICAgIGV2ZW50cy5zZXQocmlnaWRCb2R5LmhhbmRsZSwgZXZlbnRIYW5kbGVycyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5kZWxldGUocmlnaWRCb2R5LmhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW29uV2FrZSwgb25TbGVlcCwgb25Db2xsaXNpb25FbnRlciwgb25Db2xsaXNpb25FeGl0LCBvbkludGVyc2VjdGlvbkVudGVyLCBvbkludGVyc2VjdGlvbkV4aXQsIG9uQ29udGFjdEZvcmNlXSk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGEgVmVjdG9yMyBhbmQgcmV0dXJzIGEgVGhyZWUuVmVjdG9yM1xuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5jb25zdCB2ZWMzID0gKHtcbiAgeCxcbiAgeSxcbiAgelxufSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgejogMFxufSkgPT4ge1xuICByZXR1cm4gbmV3IFZlY3RvcjMoeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGEgUXVhdGVybmlvbiBhbmQgcmV0dXJzIGEgVGhyZWUuUXVhdGVybmlvblxuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5jb25zdCBxdWF0ID0gKHtcbiAgeCxcbiAgeSxcbiAgeixcbiAgd1xufSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgejogMCxcbiAgdzogMVxufSkgPT4ge1xuICByZXR1cm4gbmV3IFF1YXRlcm5pb24oeCwgeSwgeiwgdyk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGFuIEV1bGVyIGFuZCByZXR1cnMgYSBUaHJlZS5FdWxlclxuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5jb25zdCBldWxlciA9ICh7XG4gIHgsXG4gIHksXG4gIHpcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDBcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBFdWxlcih4LCB5LCB6KTtcbn07XG5cbi8qKlxuICogQSBjb2xsaWRlciBpcyBhIHNoYXBlIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgcmlnaWQgYm9keSB0byBkZWZpbmUgaXRzIHBoeXNpY2FsIHByb3BlcnRpZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQW55Q29sbGlkZXIgPSAvKiNfX1BVUkVfXyovbWVtbyhwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlLFxuICAgIG5hbWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgd29ybGQsXG4gICAgY29sbGlkZXJFdmVudHMsXG4gICAgY29sbGlkZXJTdGF0ZXNcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByaWdpZEJvZHlDb250ZXh0ID0gdXNlUmlnaWRCb2R5Q29udGV4dCgpO1xuICBjb25zdCBjb2xsaWRlclJlZiA9IHVzZUZvcndhcmRlZFJlZihwcm9wcy5yZWYpO1xuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gV2Ugc3ByZWFkIHRoZSBwcm9wcyBvdXQgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmVmIGlzIHVwZGF0ZWQgd2hlbiB0aGUgcHJvcHMgY2hhbmdlLlxuICBjb25zdCBpbW11dGFibGVQcm9wQXJyYXkgPSBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMuZmxhdE1hcChrZXkgPT5cbiAgLy8gQXJyYXkuaXNBcnJheShwcm9wc1trZXldKSA/IFsuLi5wcm9wc1trZXldXSA6IHByb3BzW2tleV1cbiAgQXJyYXkuaXNBcnJheShwcm9wc1trZXldKSA/IHByb3BzW2tleV0gOiBbcHJvcHNba2V5XV0pO1xuICBjb25zdCBnZXRJbnN0YW5jZSA9IHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgY29uc3Qgd29ybGRTY2FsZSA9IG9iamVjdFJlZi5jdXJyZW50LmdldFdvcmxkU2NhbGUodmVjMygpKTtcbiAgICBjb25zdCBjb2xsaWRlciA9IGNyZWF0ZUNvbGxpZGVyRnJvbU9wdGlvbnMocHJvcHMsIHdvcmxkLCB3b3JsZFNjYWxlLCByaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQuZ2V0UmlnaWRCb2R5KTtcbiAgICBpZiAodHlwZW9mIHByb3BzLnJlZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb3BzLnJlZihjb2xsaWRlcik7XG4gICAgfVxuICAgIGNvbGxpZGVyUmVmLmN1cnJlbnQgPSBjb2xsaWRlcjtcbiAgICByZXR1cm4gY29sbGlkZXI7XG4gIH0sIGNvbGxpZGVyID0+IHtcbiAgICBpZiAod29ybGQuZ2V0Q29sbGlkZXIoY29sbGlkZXIuaGFuZGxlKSkge1xuICAgICAgd29ybGQucmVtb3ZlQ29sbGlkZXIoY29sbGlkZXIsIHRydWUpO1xuICAgIH1cbiAgfSwgWy4uLmltbXV0YWJsZVByb3BBcnJheSwgcmlnaWRCb2R5Q29udGV4dF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gZ2V0SW5zdGFuY2UoKTtcbiAgICBjb2xsaWRlclN0YXRlcy5zZXQoY29sbGlkZXIuaGFuZGxlLCBjcmVhdGVDb2xsaWRlclN0YXRlKGNvbGxpZGVyLCBvYmplY3RSZWYuY3VycmVudCwgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0LnJlZi5jdXJyZW50KSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbGxpZGVyU3RhdGVzLmRlbGV0ZShjb2xsaWRlci5oYW5kbGUpO1xuICAgIH07XG4gIH0sIFtnZXRJbnN0YW5jZV0pO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyKHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5vcHRpb25zKSksIHByb3BzKTtcbiAgfSwgW3Byb3BzLCByaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQub3B0aW9uc10pO1xuICB1c2VVcGRhdGVDb2xsaWRlck9wdGlvbnMoZ2V0SW5zdGFuY2UsIG1lcmdlZFByb3BzLCBjb2xsaWRlclN0YXRlcyk7XG4gIHVzZUNvbGxpZGVyRXZlbnRzKGdldEluc3RhbmNlLCBtZXJnZWRQcm9wcywgY29sbGlkZXJFdmVudHMsIGdldEFjdGl2ZUNvbGxpc2lvbkV2ZW50c0Zyb21Qcm9wcyhyaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQub3B0aW9ucykpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uOiBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICByZWY6IG9iamVjdFJlZixcbiAgICBuYW1lOiBuYW1lXG4gIH0sIGNoaWxkcmVuKTtcbn0pO1xuLyoqXG4gKiBBIGN1Ym9pZCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDdWJvaWRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgc2hhcGU6IFwiY3Vib2lkXCIsXG4gICAgcmVmOiByZWZcbiAgfSkpO1xufSk7XG5DdWJvaWRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ3Vib2lkQ29sbGlkZXJcIjtcbi8qKlxuICogQSByb3VuZCBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgUm91bmRDdWJvaWRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ3Vib2lkXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDdWJvaWRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDdWJvaWRDb2xsaWRlclwiO1xuLyoqXG4gKiBBIGJhbGwgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQmFsbENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiYmFsbFwiLFxuICByZWY6IHJlZlxufSkpKTtcbkJhbGxDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQmFsbENvbGxpZGVyXCI7XG4vKipcbiAqIEEgY2Fwc3VsZSBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDYXBzdWxlQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjYXBzdWxlXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ2Fwc3VsZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDYXBzdWxlQ29sbGlkZXJcIjtcbi8qKlxuICogQSBoZWlnaHRmaWVsZCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBIZWlnaHRmaWVsZENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiaGVpZ2h0ZmllbGRcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5IZWlnaHRmaWVsZENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJIZWlnaHRmaWVsZENvbGxpZGVyXCI7XG4vKipcbiAqIEEgdHJpbWVzaCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBUcmltZXNoQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJ0cmltZXNoXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuVHJpbWVzaENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJUcmltZXNoQ29sbGlkZXJcIjtcbi8qKlxuICogQSBjb25lIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IENvbmVDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImNvbmVcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5Db25lQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkNvbmVDb2xsaWRlclwiO1xuLyoqXG4gKiBBIHJvdW5kIGN5bGluZGVyIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ29uZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwicm91bmRDb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDb25lQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ29uZUNvbGxpZGVyXCI7XG4vKipcbiAqIEEgY3lsaW5kZXIgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ3lsaW5kZXJDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImN5bGluZGVyXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ3lsaW5kZXJDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ3lsaW5kZXJDb2xsaWRlclwiO1xuLyoqXG4gKiBBIHJvdW5kIGN5bGluZGVyIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ3lsaW5kZXJDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ3lsaW5kZXJcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5DeWxpbmRlckNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJSb3VuZEN5bGluZGVyQ29sbGlkZXJcIjtcbi8qKlxuICogQSBjb252ZXggaHVsbCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb252ZXhIdWxsQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb252ZXhIdWxsXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29udmV4SHVsbENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb252ZXhIdWxsQ29sbGlkZXJcIjtcblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJyZWZcIiwgXCJjaGlsZHJlblwiLCBcInR5cGVcIiwgXCJwb3NpdGlvblwiLCBcInJvdGF0aW9uXCIsIFwic2NhbGVcIiwgXCJxdWF0ZXJuaW9uXCIsIFwidHJhbnNmb3JtU3RhdGVcIl07XG5jb25zdCBSaWdpZEJvZHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IHVzZVJpZ2lkQm9keUNvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KFJpZ2lkQm9keUNvbnRleHQpO1xuLyoqXG4gKiBBIHJpZ2lkIGJvZHkgaXMgYSBwaHlzaWNhbCBvYmplY3QgdGhhdCBjYW4gYmUgc2ltdWxhdGVkIGJ5IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBjYXRlZ29yeSBDb21wb25lbnRzXG4gKi9cbmNvbnN0IFJpZ2lkQm9keSA9IC8qI19fUFVSRV9fKi9tZW1vKHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICB0eXBlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICByb3RhdGlvbixcbiAgICAgIHNjYWxlLFxuICAgICAgcXVhdGVybmlvbixcbiAgICAgIHRyYW5zZm9ybVN0YXRlXG4gICAgfSA9IHByb3BzLFxuICAgIG9iamVjdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMSk7XG4gIGNvbnN0IG9iamVjdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmlnaWRCb2R5UmVmID0gdXNlRm9yd2FyZGVkUmVmKHJlZik7XG4gIGNvbnN0IHtcbiAgICB3b3JsZCxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgcGh5c2ljc09wdGlvbnMsXG4gICAgcmlnaWRCb2R5RXZlbnRzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGh5c2ljc09wdGlvbnMpLCBwcm9wcyksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sIFtwaHlzaWNzT3B0aW9ucywgcHJvcHNdKTtcbiAgY29uc3QgaW1tdXRhYmxlUHJvcEFycmF5ID0gaW1tdXRhYmxlUmlnaWRCb2R5T3B0aW9ucy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWVyZ2VkT3B0aW9uc1trZXldKSA/IFsuLi5tZXJnZWRPcHRpb25zW2tleV1dIDogbWVyZ2VkT3B0aW9uc1trZXldO1xuICB9KTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgbWVyZ2VkT3B0aW9ucyk7XG5cbiAgLy8gUHJvdmlkZSBhIHdheSB0byBlYWdlcmx5IGNyZWF0ZSByaWdpZGJvZHlcbiAgY29uc3QgZ2V0UmlnaWRCb2R5ID0gdXNlSW1wZXJhdGl2ZUluc3RhbmNlKCgpID0+IHtcbiAgICBjb25zdCBkZXNjID0gcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zKG1lcmdlZE9wdGlvbnMpO1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IHdvcmxkLmNyZWF0ZVJpZ2lkQm9keShkZXNjKTtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWYocmlnaWRCb2R5KTtcbiAgICB9XG4gICAgcmlnaWRCb2R5UmVmLmN1cnJlbnQgPSByaWdpZEJvZHk7XG4gICAgcmV0dXJuIHJpZ2lkQm9keTtcbiAgfSwgcmlnaWRCb2R5ID0+IHtcbiAgICBpZiAod29ybGQuZ2V0UmlnaWRCb2R5KHJpZ2lkQm9keS5oYW5kbGUpKSB7XG4gICAgICB3b3JsZC5yZW1vdmVSaWdpZEJvZHkocmlnaWRCb2R5KTtcbiAgICB9XG4gIH0sIGltbXV0YWJsZVByb3BBcnJheSk7XG5cbiAgLy8gT25seSBwcm92aWRlIGEgb2JqZWN0IHN0YXRlIGFmdGVyIHRoZSByZWYgaGFzIGJlZW4gc2V0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gZ2V0UmlnaWRCb2R5KCk7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVSaWdpZEJvZHlTdGF0ZSh7XG4gICAgICByaWdpZEJvZHksXG4gICAgICBvYmplY3Q6IG9iamVjdFJlZi5jdXJyZW50XG4gICAgfSk7XG4gICAgcmlnaWRCb2R5U3RhdGVzLnNldChyaWdpZEJvZHkuaGFuZGxlLCBwcm9wcy50cmFuc2Zvcm1TdGF0ZSA/IHByb3BzLnRyYW5zZm9ybVN0YXRlKHN0YXRlKSA6IHN0YXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmlnaWRCb2R5U3RhdGVzLmRlbGV0ZShyaWdpZEJvZHkuaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbZ2V0UmlnaWRCb2R5XSk7XG4gIHVzZVVwZGF0ZVJpZ2lkQm9keU9wdGlvbnMoZ2V0UmlnaWRCb2R5LCBtZXJnZWRPcHRpb25zLCByaWdpZEJvZHlTdGF0ZXMpO1xuICB1c2VSaWdpZEJvZHlFdmVudHMoZ2V0UmlnaWRCb2R5LCBtZXJnZWRPcHRpb25zLCByaWdpZEJvZHlFdmVudHMpO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmOiBvYmplY3RSZWYsXG4gICAgICBnZXRSaWdpZEJvZHk6IGdldFJpZ2lkQm9keSxcbiAgICAgIG9wdGlvbnM6IG1lcmdlZE9wdGlvbnNcbiAgICB9O1xuICB9LCBbZ2V0UmlnaWRCb2R5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSaWdpZEJvZHlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG9iamVjdFJlZlxuICB9LCBvYmplY3RQcm9wcywge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGVcbiAgfSksIGNoaWxkcmVuLCBjaGlsZENvbGxpZGVyUHJvcHMubWFwKChjb2xsaWRlclByb3BzLCBpbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGluZGV4XG4gIH0sIGNvbGxpZGVyUHJvcHMpKSkpKTtcbn0pO1xuUmlnaWRCb2R5LmRpc3BsYXlOYW1lID0gXCJSaWdpZEJvZHlcIjtcblxuLyoqXG4gKiBBIG1lc2ggY29sbGlkZXIgaXMgYSBjb2xsaWRlciB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdGhlIGdlb21ldHJ5IG9mIHRoZSBjaGlsZHJlbi5cbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgTWVzaENvbGxpZGVyID0gLyojX19QVVJFX18qL21lbW8ocHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgdHlwZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBwaHlzaWNzT3B0aW9uc1xuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IG9iamVjdCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNcbiAgfSA9IHVzZVJpZ2lkQm9keUNvbnRleHQoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGh5c2ljc09wdGlvbnMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gICAgICBjb2xsaWRlcnM6IHR5cGVcbiAgICB9KTtcbiAgfSwgW3BoeXNpY3NPcHRpb25zLCBvcHRpb25zXSk7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3QsIG1lcmdlZE9wdGlvbnMsIGZhbHNlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHJlZjogb2JqZWN0LFxuICAgIHVzZXJEYXRhOiB7XG4gICAgICByM1JhcGllclR5cGU6IFwiTWVzaENvbGxpZGVyXCJcbiAgICB9XG4gIH0sIGNoaWxkcmVuLCBjaGlsZENvbGxpZGVyUHJvcHMubWFwKChjb2xsaWRlclByb3BzLCBpbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGluZGV4XG4gIH0sIGNvbGxpZGVyUHJvcHMpKSkpO1xufSk7XG5NZXNoQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIk1lc2hDb2xsaWRlclwiO1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJyZWZcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiLCBcImluc3RhbmNlc1wiLCBcImNvbGxpZGVyTm9kZXNcIiwgXCJwb3NpdGlvblwiLCBcInJvdGF0aW9uXCIsIFwicXVhdGVybmlvblwiLCBcInNjYWxlXCJdO1xuY29uc3QgSW5zdGFuY2VkUmlnaWRCb2RpZXMgPSAvKiNfX1BVUkVfXyovbWVtbyhfcmVmID0+IHtcbiAgbGV0IHtcbiAgICAgIHJlZlxuICAgIH0gPSBfcmVmLFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIGNvbnN0IHJpZ2lkQm9kaWVzUmVmID0gdXNlRm9yd2FyZGVkUmVmKHJlZiwgW10pO1xuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluc3RhbmNlV3JhcHBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgICAgLy8gaW5zdGFuY2VkIHByb3BzXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGluc3RhbmNlcyxcbiAgICAgIGNvbGxpZGVyTm9kZXMgPSBbXSxcbiAgICAgIC8vIHdyYXBwZXIgb2JqZWN0IHByb3BzXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcXVhdGVybmlvbixcbiAgICAgIHNjYWxlXG5cbiAgICAgIC8vIHJpZ2lkIGJvZHkgc3BlY2lmaWMgcHJvcHMsIGFuZCByM2Ytb2JqZWN0IHByb3BzXG4gICAgfSA9IHByb3BzLFxuICAgIHJpZ2lkQm9keVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQyKTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByb3BzKSwge30sIHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0pKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2VkTWVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gaW5zdGFuY2VXcmFwcGVyUmVmLmN1cnJlbnQuY2hpbGRyZW5bMF07XG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgXCJpc0luc3RhbmNlZE1lc2hcIiBpbiBmaXJzdENoaWxkKSB7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gZ2V0SW5zdGFuY2VkTWVzaCgpO1xuICAgIGlmIChpbnN0YW5jZWRNZXNoKSB7XG4gICAgICBpbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4LnNldFVzYWdlKER5bmFtaWNEcmF3VXNhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJJbnN0YW5jZWRSaWdpZEJvZGllcyBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkLCB3aGljaCBtdXN0IGJlIGFuIEluc3RhbmNlZE1lc2hcIik7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBSaWdpZEJvZHlTdGF0ZXMgd2hlbmV2ZXIgdGhlIGluc3RhbmNlcyBjaGFuZ2VcbiAgY29uc3QgYXBwbHlJbnN0YW5jZWRTdGF0ZSA9IChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gZ2V0SW5zdGFuY2VkTWVzaCgpO1xuICAgIGlmIChpbnN0YW5jZWRNZXNoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgZ2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG1lc2hUeXBlOiBcImluc3RhbmNlZE1lc2hcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogb2JqZWN0UmVmXG4gIH0sIHJpZ2lkQm9keVByb3BzLCB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uOiBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlOiBzY2FsZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCB7XG4gICAgcmVmOiBpbnN0YW5jZVdyYXBwZXJSZWZcbiAgfSwgY2hpbGRyZW4pLCBpbnN0YW5jZXMgPT09IG51bGwgfHwgaW5zdGFuY2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW5jZXMubWFwKChpbnN0YW5jZSwgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJpZ2lkQm9keSwgX2V4dGVuZHMoe30sIHJpZ2lkQm9keVByb3BzLCBpbnN0YW5jZSwge1xuICAgIHJlZjogYm9keSA9PiB7XG4gICAgICByaWdpZEJvZGllc1JlZi5jdXJyZW50W2luZGV4XSA9IGJvZHk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm1TdGF0ZTogc3RhdGUgPT4gYXBwbHlJbnN0YW5jZWRTdGF0ZShzdGF0ZSwgaW5kZXgpXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29sbGlkZXJOb2Rlcy5tYXAoKG5vZGUsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGcmFnbWVudCwge1xuICAgIGtleTogaW5kZXhcbiAgfSwgbm9kZSkpLCBjaGlsZENvbGxpZGVyUHJvcHMubWFwKChjb2xsaWRlclByb3BzLCBjb2xsaWRlckluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe1xuICAgIGtleTogY29sbGlkZXJJbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKSkpKTtcbn0pO1xuSW5zdGFuY2VkUmlnaWRCb2RpZXMuZGlzcGxheU5hbWUgPSBcIkluc3RhbmNlZFJpZ2lkQm9kaWVzXCI7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHVzZUltcHVsc2VKb2ludCA9IChib2R5MSwgYm9keTIsIHBhcmFtcykgPT4ge1xuICBjb25zdCB7XG4gICAgd29ybGRcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBqb2ludFJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICB1c2VJbXBlcmF0aXZlSW5zdGFuY2UoKCkgPT4ge1xuICAgIGlmIChib2R5MS5jdXJyZW50ICYmIGJvZHkyLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IG5ld0pvaW50ID0gd29ybGQuY3JlYXRlSW1wdWxzZUpvaW50KHBhcmFtcywgYm9keTEuY3VycmVudCwgYm9keTIuY3VycmVudCwgdHJ1ZSk7XG4gICAgICBqb2ludFJlZi5jdXJyZW50ID0gbmV3Sm9pbnQ7XG4gICAgICByZXR1cm4gbmV3Sm9pbnQ7XG4gICAgfVxuICB9LCBqb2ludCA9PiB7XG4gICAgaWYgKGpvaW50KSB7XG4gICAgICBqb2ludFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHdvcmxkLmdldEltcHVsc2VKb2ludChqb2ludC5oYW5kbGUpKSB7XG4gICAgICAgIHdvcmxkLnJlbW92ZUltcHVsc2VKb2ludChqb2ludCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBqb2ludFJlZjtcbn07XG5cbi8qKlxuICogQSBmaXhlZCBqb2ludCBlbnN1cmVzIHRoYXQgdHdvIHJpZ2lkLWJvZGllcyBkb24ndCBtb3ZlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuXG4gKiBGaXhlZCBqb2ludHMgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGZyYW1lIChyZXByZXNlbnRlZCBieSBhbiBpc29tZXRyeSkgb24gZWFjaCByaWdpZC1ib2R5LlxuICogVGhlIGZpeGVkLWpvaW50IG1ha2VzIHRoZXNlIGZyYW1lcyBjb2luY2lkZSBpbiB3b3JsZC1zcGFjZS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlRml4ZWRKb2ludCA9IChib2R5MSwgYm9keTIsIFtib2R5MUFuY2hvciwgYm9keTFMb2NhbEZyYW1lLCBib2R5MkFuY2hvciwgYm9keTJMb2NhbEZyYW1lXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHJhcGllci5Kb2ludERhdGEuZml4ZWQodmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKSwgcXVhdGVybmlvblRvUmFwaWVyUXVhdGVybmlvbihib2R5MUxvY2FsRnJhbWUpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpLCBxdWF0ZXJuaW9uVG9SYXBpZXJRdWF0ZXJuaW9uKGJvZHkyTG9jYWxGcmFtZSkpKTtcbn07XG5cbi8qKlxuICogVGhlIHNwaGVyaWNhbCBqb2ludCBlbnN1cmVzIHRoYXQgdHdvIHBvaW50cyBvbiB0aGUgbG9jYWwtc3BhY2VzIG9mIHR3byByaWdpZC1ib2RpZXMgYWx3YXlzIGNvaW5jaWRlIChpdCBwcmV2ZW50cyBhbnkgcmVsYXRpdmVcbiAqIHRyYW5zbGF0aW9uYWwgbW90aW9uIGF0IHRoaXMgcG9pbnRzKS4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBzaW11bGF0ZSByYWdkb2xscyBhcm1zLCBwZW5kdWx1bXMsIGV0Yy5cbiAqIFRoZXkgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBvbiBlYWNoIHJpZ2lkLWJvZHkuIEVhY2ggYW5jaG9yIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZVxuICogcG9pbnRzIHRoYXQgbmVlZCB0byBjb2luY2lkZSBvbiB0aGUgbG9jYWwtc3BhY2Ugb2YgZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5jb25zdCB1c2VTcGhlcmljYWxKb2ludCA9IChib2R5MSwgYm9keTIsIFtib2R5MUFuY2hvciwgYm9keTJBbmNob3JdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcmFwaWVyLkpvaW50RGF0YS5zcGhlcmljYWwodmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSkpO1xufTtcblxuLyoqXG4gKiBUaGUgcmV2b2x1dGUgam9pbnQgcHJldmVudHMgYW55IHJlbGF0aXZlIG1vdmVtZW50IGJldHdlZW4gdHdvIHJpZ2lkLWJvZGllcywgZXhjZXB0IGZvciByZWxhdGl2ZVxuICogcm90YXRpb25zIGFsb25nIG9uZSBheGlzLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIHNpbXVsYXRlIHdoZWVscywgZmFucywgZXRjLlxuICogVGhleSBhcmUgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgYW5jaG9yIGFzIHdlbGwgYXMgb25lIGxvY2FsIGF4aXMgb24gZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5jb25zdCB1c2VSZXZvbHV0ZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgYXhpcywgbGltaXRzXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5yZXZvbHV0ZSh2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYXhpcykpO1xuICBpZiAobGltaXRzKSB7XG4gICAgcGFyYW1zLmxpbWl0c0VuYWJsZWQgPSB0cnVlO1xuICAgIHBhcmFtcy5saW1pdHMgPSBsaW1pdHM7XG4gIH1cbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIFRoZSBwcmlzbWF0aWMgam9pbnQgcHJldmVudHMgYW55IHJlbGF0aXZlIG1vdmVtZW50IGJldHdlZW4gdHdvIHJpZ2lkLWJvZGllcywgZXhjZXB0IGZvciByZWxhdGl2ZSB0cmFuc2xhdGlvbnMgYWxvbmcgb25lIGF4aXMuXG4gKiBJdCBpcyBjaGFyYWN0ZXJpemVkIGJ5IG9uZSBsb2NhbCBhbmNob3IgYXMgd2VsbCBhcyBvbmUgbG9jYWwgYXhpcyBvbiBlYWNoIHJpZ2lkLWJvZHkuIEluIDNELCBhbiBvcHRpb25hbFxuICogbG9jYWwgdGFuZ2VudCBheGlzIGNhbiBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggcmlnaWQtYm9keS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlUHJpc21hdGljSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCBheGlzLCBsaW1pdHNdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnByaXNtYXRpYyh2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYXhpcykpO1xuICBpZiAobGltaXRzKSB7XG4gICAgcGFyYW1zLmxpbWl0c0VuYWJsZWQgPSB0cnVlO1xuICAgIHBhcmFtcy5saW1pdHMgPSBsaW1pdHM7XG4gIH1cbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIFRoZSByb3BlIGpvaW50IGxpbWl0cyB0aGUgbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIGJvZGllcy5cbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5jb25zdCB1c2VSb3BlSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCBsZW5ndGhdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCB2Qm9keTFBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpO1xuICBjb25zdCB2Qm9keTJBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnJvcGUobGVuZ3RoLCB2Qm9keTFBbmNob3IsIHZCb2R5MkFuY2hvcik7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBUaGUgc3ByaW5nIGpvaW50IGFwcGxpZXMgYSBmb3JjZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIG9iamVjdHMuXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlU3ByaW5nSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCByZXN0TGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmddKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCB2Qm9keTFBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpO1xuICBjb25zdCB2Qm9keTJBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnNwcmluZyhyZXN0TGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmcsIHZCb2R5MUFuY2hvciwgdkJvZHkyQW5jaG9yKTtcbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW4gSW50ZXJhY3Rpb25Hcm91cCBiaXRtYXNrIGZvciB1c2UgaW4gdGhlIGBjb2xsaXNpb25Hcm91cHNgIG9yIGBzb2x2ZXJHcm91cHNgXG4gKiBwcm9wZXJ0aWVzIG9mIFJpZ2lkQm9keSBvciBDb2xsaWRlciBjb21wb25lbnRzLiBUaGUgZmlyc3QgYXJndW1lbnQgcmVwcmVzZW50cyBhIGxpc3Qgb2ZcbiAqIGdyb3VwcyB0aGUgZW50aXR5IGlzIGluIChleHByZXNzZWQgYXMgbnVtYmVycyBmcm9tIDAgdG8gMTUpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgbGlzdFxuICogb2YgZ3JvdXBzIHRoYXQgd2lsbCBiZSBmaWx0ZXJlZCBhZ2FpbnN0LiBXaGVuIGl0IGlzIG9taXR0ZWQsIGFsbCBncm91cHMgYXJlIGZpbHRlcmVkIGFnYWluc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIEEgUmlnaWRCb2R5IHRoYXQgaXMgbWVtYmVyIG9mIGdyb3VwIDAgYW5kIHdpbGwgY29sbGlkZSB3aXRoIGV2ZXJ5dGhpbmcgZnJvbSBncm91cHMgMCBhbmQgMTpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMF0sIFswLCAxXSl9IC8+XG4gKiBgYGBcbiAqXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cHMgMCBhbmQgMSBhbmQgd2lsbCBjb2xsaWRlIHdpdGggZXZlcnl0aGluZyBlbHNlOlxuICpcbiAqIGBgYHRzeFxuICogPFJpZ2lkQm9keSBjb2xsaXNpb25Hcm91cHM9e2ludGVyYWN0aW9uR3JvdXBzKFswLCAxXSl9IC8+XG4gKiBgYGBcbiAqXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cHMgMCBhbmQgMSBhbmQgd2lsbCBub3QgY29sbGlkZSB3aXRoIGFueXRoaW5nOlxuICpcbiAqIGBgYHRzeFxuICogPFJpZ2lkQm9keSBjb2xsaXNpb25Hcm91cHM9e2ludGVyYWN0aW9uR3JvdXBzKFswLCAxXSwgW10pfSAvPlxuICogYGBgXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBSYXBpZXIgbmVlZHMgaW50ZXJhY3Rpb24gZmlsdGVycyB0byBldmFsdWF0ZSB0byB0cnVlIGJldHdlZW4gX2JvdGhfIGNvbGxpZGluZ1xuICogZW50aXRpZXMgZm9yIGNvbGxpc2lvbiBldmVudHMgdG8gdHJpZ2dlci5cbiAqXG4gKiBAcGFyYW0gbWVtYmVyc2hpcHMgR3JvdXBzIHRoZSBjb2xsaWRlciBpcyBhIG1lbWJlciBvZi4gKFZhbHVlcyBjYW4gcmFuZ2UgZnJvbSAwIHRvIDE1LilcbiAqIEBwYXJhbSBmaWx0ZXJzIEdyb3VwcyB0aGUgaW50ZXJhY3Rpb24gZ3JvdXAgc2hvdWxkIGZpbHRlciBhZ2FpbnN0LiAoVmFsdWVzIGNhbiByYW5nZSBmcm9tIDAgdG8gMTUuKVxuICogQHJldHVybnMgQW4gSW50ZXJhY3Rpb25Hcm91cCBiaXRtYXNrLlxuICovXG5jb25zdCBpbnRlcmFjdGlvbkdyb3VwcyA9IChtZW1iZXJzaGlwcywgZmlsdGVycykgPT4gKGJpdG1hc2sobWVtYmVyc2hpcHMpIDw8IDE2KSArIChmaWx0ZXJzICE9PSB1bmRlZmluZWQgPyBiaXRtYXNrKGZpbHRlcnMpIDogMGIxMTExMTExMTExMTExMTExKTtcbmNvbnN0IGJpdG1hc2sgPSBncm91cHMgPT4gW2dyb3Vwc10uZmxhdCgpLnJlZHVjZSgoYWNjLCBsYXllcikgPT4gYWNjIHwgMSA8PCBsYXllciwgMCk7XG5cbmV4cG9ydCB7IEFueUNvbGxpZGVyLCBCYWxsQ29sbGlkZXIsIENhcHN1bGVDb2xsaWRlciwgQ29uZUNvbGxpZGVyLCBDb252ZXhIdWxsQ29sbGlkZXIsIEN1Ym9pZENvbGxpZGVyLCBDeWxpbmRlckNvbGxpZGVyLCBIZWlnaHRmaWVsZENvbGxpZGVyLCBJbnN0YW5jZWRSaWdpZEJvZGllcywgTWVzaENvbGxpZGVyLCBQaHlzaWNzLCBSaWdpZEJvZHksIFJvdW5kQ29uZUNvbGxpZGVyLCBSb3VuZEN1Ym9pZENvbGxpZGVyLCBSb3VuZEN5bGluZGVyQ29sbGlkZXIsIFRyaW1lc2hDb2xsaWRlciwgZXVsZXIsIGludGVyYWN0aW9uR3JvdXBzLCBxdWF0LCB1c2VBZnRlclBoeXNpY3NTdGVwLCB1c2VCZWZvcmVQaHlzaWNzU3RlcCwgdXNlRml4ZWRKb2ludCwgdXNlSW1wdWxzZUpvaW50LCB1c2VQcmlzbWF0aWNKb2ludCwgdXNlUmFwaWVyLCB1c2VSZXZvbHV0ZUpvaW50LCB1c2VSb3BlSm9pbnQsIHVzZVNwaGVyaWNhbEpvaW50LCB1c2VTcHJpbmdKb2ludCwgdmVjMyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js\n");

/***/ })

};
;